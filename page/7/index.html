<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="一只在迈向机器学习道路上狂奔的程序猿." />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="一只在迈向机器学习道路上狂奔的程序猿.">
<meta property="og:type" content="website">
<meta property="og:title" content="DannyLee">
<meta property="og:url" content="http://dannylee1991.github.io/page/7/index.html">
<meta property="og:site_name" content="DannyLee">
<meta property="og:description" content="一只在迈向机器学习道路上狂奔的程序猿.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DannyLee">
<meta name="twitter:description" content="一只在迈向机器学习道路上狂奔的程序猿.">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

<!--baidu统计-->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2f967e5ec4f276411160d27aeace7722";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

  <title> DannyLee </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">DannyLee</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
        <li class="menu-item menu-item-search">
          <a href="#" class="st-search-show-outputs">
            <i class="menu-item-icon icon-next-search"></i> <br />
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'ss9-_Hsd4DyhyGw4m99P','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/07/22/gradle学习笔记-使用gradle图形界面/" itemprop="url">
                gradle学习笔记-使用gradle图形界面
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-07-22T15:06:55+08:00" content="2016-07-22">
            2016-07-22
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/gradle/" itemprop="url" rel="index">
                  <span itemprop="name">gradle</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/07/22/gradle学习笔记-使用gradle图形界面/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/22/gradle学习笔记-使用gradle图形界面/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>除了支持传统的命令行界面，Gradle提供了一个图形用户界面。可以通过<code>--gui</code>选项来开启。</p>
</blockquote>
<p><strong>Example 10.1. Launching the GUI</strong></p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gradle <span class="comment">--gui</span></div></pre></td></tr></table></figure>
<blockquote>
<p>请注意这条命令会阻塞进程直到关闭GUI，在*nix下，使用<code>gradle --gui&amp;</code>这条命令，使得它运行在一个后台任务中是一个更好的选择。</p>
</blockquote>
<p>如果你在你的gradle工作目录下运行了这个命令，你将看到一个task树。</p>
<p><strong>Figure 10.1. GUI Task Tree</strong></p>
<p><img src="/img/gradle/guiTaskTree.png" alt=""></p>
<p>最好在你的gradle项目下运行这条命令，以便于用户界面的设置将存储在您的项目目录中。你也可以运行这条命令后通过用户界面中的“设置”选项卡更改工作目录。</p>
<p>用户界面顶部有4个tab，底部有一个输出窗口。</p>
<h2 id="10-1-_Task_Tree">10.1. Task Tree</h2><p>任务树显示了所有项目和它们的任务的分层显示。双击一个任务可以执行它</p>
<p>顶部有一个过滤器按钮，您可以通过过滤器按钮切换过滤器。编辑筛选器允许您配置任务和项目所显示的项目。隐藏的task出现在红色区域中。注意：新创建的task将默认出现（相对的默认被隐藏）。</p>
<p>任务树上下文菜单提供以下选项：</p>
<ul>
<li>执行忽略依赖关系。不需要依赖的项目被重建（类似于<code>-a</code> 选项）。</li>
<li>将task添加到favorites中（见favorites tab）</li>
<li>隐藏选择的task。</li>
<li>编辑build.gradle文件。注意：这需要你的java版本&gt;= 1.6，并且你有和系统相匹配的.gradle文件。</li>
</ul>
<h2 id="10-2-_Favorites">10.2. Favorites</h2><p>Favorites tab是一个很好的用来存储经常被使用命令的地方。这里可以是一些很复杂的命令（只要是符合gradle规范的），并且你可以为他们提供一个显示名称。这可以用于：创建、说、自定义一个明确跳过测试的构建命令，文档，和样品，你可以称之为“快速构建”。</p>
<p>你可以对你列出的favorites进行重新排序，并且导出到磁盘上，并且被其他人引用。</p>
<h2 id="10-3-_Command_Line">10.3. Command Line</h2><p>命令行界面你可以直接输入一条gradle命令。在你将命令添加到Favorites中，这也是一个让你尝试gradle命令的好地方。</p>
<h2 id="10-4-_Setup">10.4. Setup</h2><p>设置选项卡允许一些一般设置的配置。</p>
<p><strong>Figure 10.2. GUI Setup</strong></p>
<p><img src="/img/gradle/guiSetup.png" alt=""></p>
<ul>
<li><p>当前目录</p>
<p>  设置你的gradle项目的根目录（通常是build.gradle文件的所在位置）</p>
</li>
<li><p>堆栈跟踪输出</p>
<p>  取决于当你的错误发生时，有多少信息被写入。提示：如果在命令行或“Favorites”选项卡上指定了堆栈跟踪级别，则将覆盖该堆栈跟踪级别。</p>
</li>
<li><p>只有当错误发生时才显示输出</p>
<p>  启用此选项隐藏任务执行时的任何输出，除非生成失败。</p>
</li>
<li><p>使用自定义gradle执行器 - 高级功能</p>
<p>  这为你提供了另一种方式推出Gradle的命令。如果你的项目需要一些额外的设置，这将会很有用，这是在一个批处理文件或脚本（如指定init脚本）内完成的。</p>
</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/07/22/斯坦福机器学习课程 第一周 (4)一元线性回归/" itemprop="url">
                斯坦福机器学习课程 第一周 (4)一元线性回归
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-07-22T12:07:00+08:00" content="2016-07-22">
            2016-07-22
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/机器学习/" itemprop="url" rel="index">
                  <span itemprop="name">机器学习</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/07/22/斯坦福机器学习课程 第一周 (4)一元线性回归/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/22/斯坦福机器学习课程 第一周 (4)一元线性回归/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>线性回归预测一个输入值的一个真值输出。我们讨论了线性回归在住房价格预测中的应用，提出了成本函数的概念，并介绍了学习的梯度下降法。</p>
</blockquote>
<h2 id="模型与成本函数(Model_and_Cost_Function)">模型与成本函数(Model and Cost Function)</h2><h3 id="模型表示">模型表示</h3><p><a href="https://www.coursera.org/learn/machine-learning/lecture/db3jS/model-representation" target="_blank" rel="external">视频地址</a></p>
<p>我们的第一个学习算法是<strong>线性回归算法</strong>，在这段视频中，你会看到这个算法的概况。更重要的是你将会了解监督学习过程完整的流程，让我们通过一个例子来开始。</p>
<p>这个例子是预测住房价格的，我们要使用一个数据集，数据集包含俄勒冈州波特兰市的住房价格。</p>
<p><img src="/img/16_07_22/001.png" alt=""></p>
<p>在这里我要根据不同房屋尺寸所售出的价格 画出我的数据集，比方说，我们来看这个数据集，你有一个朋友正想出售自己的房子。如果你朋友的房子是1250平方尺大小，你要告诉他们这房子能卖多少钱，那么你可以做的一件事就是，构建一个模型，也许是条直线，从这个数据模型上来看。也许你可以告诉你的朋友，他能以大约220000(美元)左右的价格卖掉这个房子。</p>
<p><img src="/img/16_07_22/002.png" alt=""></p>
<p>那么这就是监督学习算法的一个例子，<strong>它被称作监督学习是因为对于每个数据来说，我们给出了“正确的答案”</strong>，即告诉我们根据我们的数据来说，房子实际的价格是多少，而且更具体来说，这是一个<strong>回归问题</strong>。回归一词指的是我们根据之前的数据预测出一个准确的输出值。对于这个例子就是价格。</p>
<p>同时，还有另一种最常见的监督学习方式，叫做<strong>分类问题</strong>。当我们想要预测离散的输出值，例如，如果我们正在寻找癌症肿瘤并想要确定肿瘤是良性的还是恶性的，这就是0/1离散输出的问题。</p>
<p>更进一步来说，在监督学习中我们有一个数据集，这个数据集被称训练集，因此对于房价的例子，我们有一个训练集，包含不同的房屋价格。我们的任务就是从这个数据中学习预测房屋价格。</p>
<p><img src="/img/16_07_22/003.png" alt=""></p>
<p>现在我们给出这门课中经常使用的一些符号定义，我们要定义颇多符号，不过没关系，现在你记不住所有的符号也没关系，随着课程的进展，你会发现记住这些符号会很有用。我将在整个课程中<strong>用小写的m来表示训练样本的数目</strong>。</p>
<p><img src="/img/16_07_22/004.png" alt=""></p>
<p>因此 在这个数据集中，如果表中有47行，那么我们就有47组训练样本，$m$就等于47。让我用小写字母$x$来表示输入变量，往往也被称为<strong>特征量</strong>，这就是用$x$表示输入的特征，并且我们将用$y$来表示输出变量或者目标变量，也就是我的预测结果。那么这就是第二列，在这里我要使用$(x,y)$来表示一个训练样本，所以在这个表格中的单独的一行对应于一个训​​练样本，为了表示某个训练样本，我将使用$x^{(i)}$与$y^{(i)}$来表示。并且用这个表示第$i$个训练样本，所以这个上标$i$不是求幂运算，这个$(x^{(i)},y^{(i)})$括号里的上标$i$只是一个索引，表示我的训练集里的第i行。这里不是x的i和y的i次方，仅仅是指$(x^{(i)},y^{(i)})$是在此表中的第$i$行。</p>
<p>举个例子$x^{(1)}$指的是第一个训练集里值为2104的输入值，这个就是第一行里的$x$，$x^{(2)}$ 等于1416吧?这是第二个$x$，$y^{(1)}$等于460，这是我第一个训练集样本的$y$值，这就是$^{(1)}$所代表的含义。</p>
<p><img src="/img/16_07_22/005.png" alt=""></p>
<p>像之前一样，我会问你一个问题，需要几秒的时间检查一下你的理解程度，在这个视频片段中，有时会有视频选择题弹出,当它弹出的时候,请使用鼠标来选择你认为正确的答案。这就是一个监督学习算法的工作方式。我们可以看到这里有我们的训练集里房屋价格，我们把它喂给我们的学习算法，这就是学习算法的工作了。然后输出一个函数，按照惯例，通常表示为小写h，<strong>$h$代表hypothesis(假设)</strong>，$h$表示一个函数，输入是房屋尺寸大小。就像你朋友想出售的房屋。因此 h 根据输入的$x$值来得出$y$值，$y$值对应房子的价格，因此，$h$是一个从$x$到$y$的函数映射。</p>
<p><img src="/img/16_07_22/006.png" alt=""></p>
<p>人们经常问我为什么这个函数被称作假设(hypothesis)，你们中有些人可能知道hypothesis的意思，从字典或者其它什么方式可以查到。其实在机器学习中这是一个在早期被用于机器学习的名称，它有点绕口。对这类函数来说，这可能不是一个很恰当的名字，对表示从房屋的大小到价格的函数映射，我认为这个词“hypothesis”可能不是最好的名称，但是这是人们在机器学习中使用的标准术语。所以不用太纠结人们为什么这么叫它。</p>
<p>当设计学习算法的时候，我们接下来需要去思考的是怎样得到这个假设$h$，对于这一点在接下来的几个视频中我将选择最初的使用规则，$h$代表hypothesis。我们将会这么写：</p>
<p>$$<br>h_{θ}(x) = θ_0 + θ_1 * x<br>$$</p>
<p>为了方便有时非书面形式也可以这么写：$h_{θ}(x)$，我就写成$h(x)$，这是缩写方式。但一般来说我会保留这个下标$θ$。所以这就是数据集和函数的作用：用来预测。有时候我们会有更复杂的函数，也许是非线性函数，但是由于线性方程是简单的形式，我们将先从线性方程的例子入手。当然最终我们将会建立更复杂的模型，以及更复杂的学习算法。好吧，让我们也给这模型起一个名字，这个模型被称为线性回归<strong>(linear regression)</strong>模型。另外，这实际上是关于单个变量的线性回归，这个变量就是x。根据x来预测所有的价格函数，同时 对于这种模型有另外一个名称，称作<strong>单变量线性回归</strong>，单变量是对一个变量的一种特别的表述方式，总而言之这就是线性回归，在接下来的视频中我们将开始讨论如何去实现这种模型。</p>
<h3 id="代价函数">代价函数</h3><p><a href="https://www.coursera.org/learn/machine-learning/lecture/rkTp3/cost-function" target="_blank" rel="external">视频地址</a></p>
<p>在这段视频中我们将定义<strong>代价函数</strong>的概念，这有助于我们弄清楚如何把最有可能的直线与我们的数据相拟合。在线性回归中我们有一个像这样的训练集，记住，$M$代表了训练样本的数量。所以，比如$M = 47$。而我们的假设函数，也就是用来进行预测的函数，是这样的线性函数形式。</p>
<p><img src="/img/16_07_22/007.png" alt=""></p>
<p>接下来我们会引入一些术语，这些$θ_{0}$和$θ_{1}$，这些$θ_{i}$我把它们称为<strong>模型参数</strong>。在这个视频中，我们要做的就是谈谈如何选择这两个参数值$θ_{0}$和$θ_{1}$。选择不同的参数$θ_{0}$和$θ_{1}$，我们会得到不同的假设，不同的假设函数，我知道你们中的有些人可能已经知道我在这张幻灯片上要讲的，但我们还是用这几个例子来复习回顾一下。如果$θ_{0}=1.5$，$θ_{1}=0$ 那么假设函数会看起来是这样:</p>
<p><img src="/img/16_07_22/008.png" alt=""></p>
<p>因为你的假设函数是$h(x) = 1.5 + 0 * x$是这样一个常数函数 <code>恒等于1.5</code>。 </p>
<p>如果$θ_{0} = 0$并且$θ_{1} = 0.5$， 那么假设会看起来像这样:</p>
<p><img src="/img/16_07_22/009.png" alt=""></p>
<p>它会通过点$(2,1)$。这样你又得到了$h(x)$或者$h_{θ}(x)$。但是有时我们为了简洁会省略$θ$。因此$h(x)$将等于$0.5$倍的$x$。就像这样。</p>
<p>最后，如果$θ_{0} = 1$并且$θ_{1} = 0.5$。我们最后得到的假设会看起来像这样:</p>
<p><img src="/img/16_07_22/010.png" alt=""></p>
<p>让我们来看看它应该通过点$(2,2)$，这是我的新的$h(x)$或者写作$h_{θ}(x)$。你还记得之前我们提到过$h_{θ}(x)$的。但作为简写，我们通常只把它写作$h(x)$。</p>
<p>在线性回归中，我们有一个训练集，可能就像我在这里绘制的。我们要做的就是得出$θ_{0}$、$θ_{1}$这两个参数的值，来让假设函数表示的直线尽量地与这些数据点很好的拟合。也许就像这里的这条线一样：</p>
<p><img src="/img/16_07_22/011.png" alt=""></p>
<p>那么我们如何得出$θ_{0}$、$θ_{1}$的值来使它很好地拟合数据的呢？我们的想法是我们要选择能使$h(x)$，也就是输入$x$时我们预测的值，最接近该样本对应的$y$值的参数$θ_{0}$、$θ_{1}$。所以，在我们的训练集中我们会得到一定数量的样本。我们知道$x$表示卖出哪所房子,并且知道这所房子的实际价格。所以我们要尽量选择合适的参数值，使得在训练集中给出的$x$值，我们能合理准确地预测$y$的值。</p>
<blockquote>
<p>Idea: Choose $θ_{0}$、$θ_{1}$ so that $h_{θ}(x)$ is close to $y$ for our training examples $(x,y)$.</p>
</blockquote>
<p>让我们给出标准的定义:在线性回归中我们要解决的是一个最小化问题。所以我要写出关于$θ_{0}$、$θ_{1}$的最小化，而且我希望这个式子极其小，我想要$h(x)$和$y$之间的差异要小。我要做的事情是尽量减少假设的输出与房子真实价格之间的差的平方。</p>
<p>$$<br>\mathop{minimze}\limits_{θ_{0}θ_{1}}<br>(h_{θ}(x) - y)^{2}<br>$$</p>
<p>接下来我会详细的阐述。</p>
<p>别忘了，我用符号$(x^{(i)},y^{(i)})$代表第i个样本，所以我想要做的是对所有训练样本进行一个求和，对$i = 1$到$i = m$的样本将对假设进行预测得到的结果，此时的$x^{i}$输入是第$i$号房子的面积。将第$i$号对应的预测结果减去第$i$号房子的实际价格，所得的差的平方相加得到总和而我希望尽量减小这个值，也就是预测值和实际值的差的平方误差和，或者说预测价格和实际卖出价格的差的平方。</p>
<p>$$<br>\mathop{minimze}\limits_{θ_{0}θ_{1}}<br>\sum_{i=1}^{m}<br>(h_{θ}(x^{(i)}) - y^{(i)})^{2}<br>$$</p>
<p>我说了这里的$m$指的是训练集的样本容量。而为了让表达式的数学意义变得容易理解一点，我们实际上考虑的是这个数的$1/m$。因此我们要尝试尽量减少我们的平均误差，也就是尽量减少其$1/2m$。通常是这个数的一半。</p>
<p>$$<br>\mathop{minimze}\limits_{θ_{0}θ_{1}}<br>\frac{1}{2m}<br>\sum_{i=1}^{m}<br>(h_{θ}(x^{(i)}) - y^{(i)})^{2}<br>$$</p>
<p>前面的这些只是为了使数学更直白一点，因此对这个求和值的二分之一求最小值应该得出相同的$θ_{0}$值和相同的$θ_{1}$值来，在这里</p>
<p>$$h_{θ}(x^{(i)})=θ_{0} + θ_{1} * x^{(i)}$$</p>
<p>而这个表达式</p>
<p>$$<br>\mathop{minimze}\limits_{θ_{0}θ_{1}}<br>$$</p>
<p>意味着我们要找到$θ_{0}$和$θ_{1}$的值来使这个表达式的值最小。这个表达式因$θ_{0}$和$θ_{1}$的变化而变化。</p>
<p>因此，简单地说，我们正在把这个问题变成：找到能使我的训练集中预测值和真实值的差的平方的和的$1/2m$最小的$θ_{0}$和$θ_{1}$的值。因此，这将是我的线性回归的整体目标函数。为了使它更明确一点，我们要改写这个函数。</p>
<p>按照惯例我要定义一个代价函数：</p>
<p>$$<br>J(θ_{0},θ_{1}) =<br>\frac{1}{2m}<br>\sum_{i=1}^{m}<br>(h_{θ}(x^{(i)}) - y^{(i)})^{2}<br>$$</p>
<p>正如屏幕中所示，这里的这个公式我们想要做的就是关于$θ_{0}$和$θ_{1}$对函数$J(θ_{0}$,$θ_{1})$求最小值。这就是我的代价函数。代价函数也被称作<strong>平方误差函数</strong>，有时也被称为<strong>平方误差代价函数</strong>。事实上我们之所以要求出误差的平方和，是因为误差平方代价函数对于大多数问题，特别是回归问题，都是一个合理的选择。还有其他的代价函数也能很好地发挥作用，但是平方误差代价函数可能是解决回归问题最常用的手段了。</p>
<p>在后续课程中，我们还会谈论其他的代价函数。但我们刚刚讲的选择是对于大多数线性回归问题非常合理的。好吧，所以这是代价函数，到目前为止我们已经介绍了代价函数的数学定义，也许这个函数$J(θ_{0}$,$θ_{1})$有点抽象，可能你仍然不知道它的内涵，在接下来的几个视频里我们要更进一步解释代价函数$J$的工作原理，并尝试更直观地解释它在计算什么，以及我们使用它的目的。</p>
<h3 id="代价函数_实例1">代价函数 实例1</h3><p><a href="https://www.coursera.org/learn/machine-learning/lecture/N09c6/cost-function-intuition-i" target="_blank" rel="external">视频地址</a></p>
<p>在上一个视频中我们给了代价函数一个数学上的定义，在这个视频里 让我们通过一些例子来获取一些直观的感受，看看代价函数到底是在干什么。</p>
<p>回顾一下，这是我们上次所讲过的内容：我们想找一条直线来拟合我们的数据，所以我们用θ0，θ1等参数得到了这个假设，而且通过选择不同的参数，我们会得到不同的直线拟合。然后我们还有一个代价函数，这就是我们的优化目标。</p>
<p><strong>假设(Hypothesis):</strong></p>
<p>$$<br>h_{θ}(x) = θ_0 + θ_1 * x<br>$$</p>
<p><strong>参数(Parameters):</strong></p>
<p>$$<br>θ_0 , θ_1<br>$$</p>
<p><strong>代价函数(Cost Function):</strong></p>
<p>$$<br>J(θ_{0},θ_{1}) =<br>\frac{1}{2m}<br>\sum_{i=1}^{m}<br>(h_{θ}(x^{(i)}) - y^{(i)})^{2}<br>$$</p>
<p><strong>目标(Goal):</strong></p>
<p>$$<br>\mathop{minimze}\limits_{θ_{0}θ_{1}}<br>J(θ_{0},θ_{1})<br>$$</p>
<p>在这个视频里，为了更好地将代价函数可视化，我将使用一个简化表示方法来表示假设函数、参数、代价函数以及目标：</p>
<p><strong>简化的假设函数(Hypothesis):</strong></p>
<p>$$<br>h_{θ}(x) = θ_1 * x<br>$$</p>
<p><strong>简化的参数(Parameters):</strong></p>
<p>$$<br>θ_1<br>$$</p>
<p><strong>简化的代价函数(Cost Function):</strong></p>
<p>$$<br>J(θ_{1}) =<br>\frac{1}{2m}<br>\sum_{i=1}^{m}<br>(h_{θ}(x^{(i)}) - y^{(i)})^{2}<br>$$</p>
<p><strong>简化的目标(Goal):</strong></p>
<p>$$<br>\mathop{minimze}\limits_{θ_{1}}<br>J(θ_{1})<br>$$</p>
<p>我们可以将这个假设函数看成是把$θ_{0}$设为0，所以我只有一个参数，也就是$θ_{1}$。代价函数看起来与之前的很像，唯一的区别是现在$h(x) = θ_{1} * x$，只有一个参数$θ_{1}$，所以我的优化目标是将$J(θ_{1})$最小化。用图形来表示就是，如果$θ_{0}$等于零，也就意味这我们选择的假设函数会经过原点，也就是经过坐标$(0,0)$。通过利用简化的假设得到的代价函数 我们可以试着更好地理解代价函数这个概念。</p>
<p>我们要理解的是这两个重要的函数：第一个是假设函数，第二个是代价函数。</p>
<table>
<thead>
<tr>
<th style="text-align:center">$h_{θ}(x)$ :假设函数</th>
<th style="text-align:center">$J(θ_{1})$ :代价函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(for fixed $θ_{1}$,this is a function of x)</td>
<td style="text-align:center">(function of the parameter $θ_{1}$)</td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/16_07_22/012.png" alt=""></td>
<td style="text-align:center"><img src="/img/16_07_22/013.png" alt=""></td>
</tr>
</tbody>
</table>
<p>注意这个假设函数$h_{θ}(x)$对于一个固定的$θ_{1}$是一个关于$x$的函数。所以这个假设函数就是一个关于$x$这个房子大小的函数。与此不同的是，代价函数$J$是一个关于参数$θ_{1}$的函数，而$θ_{1}$控制着这条直线的斜率。通过上图我们可以很好的理解，比如说这里是我的训练样本，它包含了三个点$(1,1)$，$(2,2)$和$(3,3)$。现在我们选择一个值$θ_{1}$，所以当$θ_{1} = 1$，如果这是我选择的$θ_{1}$，那么我的假设函数看起来就会像是这条直线。我将要指出的是，X轴是表示房子大小的量。现在暂时把$θ_{1}$定为1，我想要做的就是算出在$θ_{1} = 1$的时候$J(θ_{1})$等于多少。所以我们按照这个思路来计算代价函数的大小，和之前一样，代价函数定义如下:</p>
<p>$$<br>\begin{align*}<br>J(θ_{1}) &amp;=<br>\frac{1}{2m}<br>\sum_{i=1}^{m}<br>(h_{θ}(x^{(i)}) - y^{(i)})^{2}\\<br> &amp;=<br>\frac{1}{2m}<br>\sum_{i=1}^{m}<br>(θ_1x^{(i)} - y^{(i)})^{2}\\<br> &amp;=<br>\frac{1}{2m}<br>(0^2 + 0^2 + 0^2)\\<br> &amp;= 0<br>\end{align*}<br>$$</p>
<p>对这个误差平方项进行求和，这就等于这样一个形式，简化以后就等于三个0的平方和，当然还是0。现在，在代价函数里，我们发现所有这些值都等于0。因为对于我所选定的这三个训练样本$(1,1)$，$(2,2)$和$(3,3)$，如果$θ_{1} = 1$，那么$h_{θ}(x^{(i)})$就会正好等于$y^{(i)}$。所以$h(x) - y$所有的这些值都会等于零。这也就是为什么$J(1) = 0$。所以我们现在知道了$J(1) = 0$，如下图，要注意的是，因为我的代价函数是关于参数$θ_{1}$的函数，当我描绘我的代价函数时，$X$轴就是$θ_{1}$。</p>
<p><img src="/img/16_07_22/014.png" alt=""></p>
<p>现在我有$J(1) = 0$，让我们继续把函数画出来，结果我们会得到这样一个点。</p>
<p>现在我们来看其它一些样本$θ_{1}$可以被设定为某个范围内各种可能的取值，所以$θ_{1}$可以取负数、0或者正数。所以如果$θ_{1} = 0.5$会发生什么呢？继续把它画出来:</p>
<p><img src="/img/16_07_22/015.png" alt=""></p>
<p>这条线的斜率等于0.5，现在让我们计算$J(0.5)$。</p>
<p>$$<br>\begin{align*}<br>J(θ_{1}) &amp;=<br>\frac{1}{2m}<br>\sum_{i=1}^{m}<br>(h_{θ}(x^{(i)}) - y^{(i)})^{2}\\<br> &amp;=<br>\frac{1}{2m}<br>\sum_{i=1}^{m}<br>(θ_1x^{(i)} - y^{(i)})^{2}\\<br> &amp;=<br>\frac{1}{2m}<br>((0.5 - 1)^2 + (1 - 2)^2 + (1.5 - 3)^2)\\<br> &amp;\approx 0.58<br>\end{align*}<br>$$</p>
<p>让我们把点画出来：</p>
<p><img src="/img/16_07_22/016.png" alt=""></p>
<p>让我们试试$θ_{1}$等于0，$J(0)$会等于多少呢？如果$θ_{1} = 0$，那么$h(x)$就会等于一条水平的线。如下图：</p>
<p><img src="/img/16_07_22/017.png" alt=""></p>
<p>计算$J(0)$：</p>
<p>$$<br>\begin{align*}<br>J(θ_{1}) &amp;=<br>\frac{1}{2m}<br>\sum_{i=1}^{m}<br>(h_{θ}(x^{(i)}) - y^{(i)})^{2}\\<br> &amp;=<br>\frac{1}{2m}<br>\sum_{i=1}^{m}<br>(θ_1x^{(i)} - y^{(i)})^{2}\\<br> &amp;=<br>\frac{1}{2m}<br>((0 - 1)^2 + (0 - 2)^2 + (0 - 3)^2)\\<br> &amp;\approx 2.33<br>\end{align*}<br>$$</p>
<p>所以让我们接着把这个点也画出来，所以这个点最后是2.3：</p>
<p><img src="/img/16_07_22/018.png" alt=""></p>
<p>当然我们可以接着设定$θ_{1}$等于别的值进行计算，你也可以把$θ_{1}$设定成一个负数，所以如果$θ_{1}$是负数，那么h(x)将会等于，打个比方说－0.5乘以x然后$θ_{1}$就是-0.5，那么这将会对应着一个斜率为-0.5的假设函数，而且你可以 继续计算这些误差。结果你会发现对于0.5结果会是非常大的误差，最后会得到一个较大的数值，类似于5.25，等等。对于不同的$θ_{1}$，你可以计算出这些对应的值，结果你会发现，你算出来的这些值，你得到一条这样的曲线，通过计算这些值，你可以慢慢地得到这条线，这就是$J(θ)$的样子了。</p>
<p><img src="/img/16_07_22/019.png" alt=""></p>
<p>我们来回顾一下，任何一个$θ_{1}$的取值对应着一个不同的假设函数，或者说对应着左边一条不同的拟合直线。对于任意的$θ_{1}$你可以算出一个不同的$J(θ1)$的取值。举个例子，你知道的$θ_{1} = 1$时对应着穿过这些数据的那条直线，当$θ_{1} = 0.5$，对应着上面斜率为0.5的那条直线，然后$θ_{1} = 0$，对应着过原点的水平的线。所以对于任意一个$θ_{1}$的取值，我们会得到一个不同的$J(θ_{1})$，而且我们可以利用这些来描出上边的这条曲线。</p>
<p><img src="/img/16_07_22/013.png" alt=""></p>
<p>现在你还记得学习算法的优化目标，是我们想找到一个$θ_{1}$的值来将$J(θ_{1})$最小化，这是我们线性回归的目标函数。嗯，看这条曲线，让$J(θ_{1})$最小化的值 是$θ_{1} = 1$，然后你看，这个确实就对应着最佳的通过了数据点的拟合直线，这条直线就是由$θ_{1} = 1$的设定而得到的，然后，对于这个特定的训练样本，我们最后能够完美地拟合。这就是为什么最小化$J(θ_{1})$对应着寻找一个最佳拟合直线的目标。总结一下，在这个视频里我们看到了一些图形来理解代价函数，要做到这个，我们简化了算法，让这个函数只有一个参数$θ_{1}$，也就是说我们把$θ_{0}$设定为0，在下一个视频里我们将回到原来的问题的公式，然后看一些带有$θ_{0}$和$θ_{1}$的图形，也就是说不把$θ_{0}$设置为0了，希望这会让你更好地理解在原来的线性回归公式里代价函数$J$的意义。</p>
<h3 id="代价函数_实例2">代价函数 实例2</h3><p><a href="https://www.coursera.org/learn/machine-learning/lecture/nwpe2/cost-function-intuition-ii" target="_blank" rel="external">视频地址</a></p>
<p>这节课中，我们将更深入地学习代价函数的作用。这段视频的内容假设你已经认识轮廓图，如果你对轮廓图不太熟悉的话，这段视频中的某些内容你可能会听不懂。但不要紧，如果你跳过这段视频的话，也没什么关系。不听这节课对后续课程理解影响不大。</p>
<p>和之前一样，这是我们的几个重要公式：</p>
<p><strong>假设(Hypothesis):</strong></p>
<p>$$<br>h_{θ}(x) = θ_0 + θ_1 * x<br>$$</p>
<p><strong>参数(Parameters):</strong></p>
<p>$$<br>θ_0 , θ_1<br>$$</p>
<p><strong>代价函数(Cost Function):</strong></p>
<p>$$<br>J(θ_{0},θ_{1}) =<br>\frac{1}{2m}<br>\sum_{i=1}^{m}<br>(h_{θ}(x^{(i)}) - y^{(i)})^{2}<br>$$</p>
<p><strong>目标(Goal):</strong></p>
<p>$$<br>\mathop{minimze}\limits_{θ_{0}θ_{1}}<br>J(θ_{0},θ_{1})<br>$$</p>
<p>跟前一节视频不同的是 我还是把$θ$写成$θ_{0}$、$θ_{1}$的形式，便于这里我们要对代价函数进行的可视化。和上次一样，首先来理解假设$h$和代价函数$J$。</p>
<p>这是房价数据组成的训练集数据:</p>
<p><img src="/img/16_07_22/020.png" alt=""></p>
<p>让我们来构建某种假设：如果我假设$θ_{0} = 50$，$θ_{1} = 0.06$的话，那么我将得到这样一个假设函数：</p>
<p><img src="/img/16_07_22/021.png" alt=""></p>
<p>那么现在的代价函数图像要怎么画呢？上一节我们只有一个$θ$，我们画出来的图形是一个倒过来的抛物线图，可是现在我们有了两个变量：$θ_{0}$和$θ_{1}$，我们的代价函数图就成了一个三维曲面图，水平方向的两个轴分别表示$θ_{0}$和$θ_{1}$，我们要在下面画出代价函数的图像：</p>
<p><img src="/img/16_07_22/022.png" alt=""></p>
<p>随着你改变$θ_{0}$和$θ_{1}$的大小，你会得到不同的代价函数 $J(θ_{0}$,$θ_{1})$对于某个特定的点$(θ_{0}$,$θ_{1})$这个曲面的高度，也就是竖直方向的高度，就表示代价函数$J(θ_{0}$,$θ_{1})$的值。</p>
<p>不难发现这是一个弓形曲面。我们来看看三维图，旋转一下这个图你就更能理解这个弓形曲面所表示的代价函数了：</p>
<p><img src="/img/16_07_22/023.gif" alt=""></p>
<p>在这段视频的后半部分，为了描述方便，我将不再像这样给你用三维曲面图的方式解释代价函数$J$，而是用<strong>轮廓图(contour plot)</strong>来表示，下边就是一个轮廓图</p>
<p><img src="/img/16_07_22/024.png" alt=""></p>
<p>两个轴分别表示$θ_{0}$和$θ_{1}$，而这些一圈一圈的椭圆形，每一个圈就表示$J(θ_{0}$,$θ_{1})$相同的所有点的集合。如果你之前没怎么接触轮廓图的话，你就这么想：一个弓形的函数从屏幕里冒出来，因此最小值也就是这个弓形的最低点就是这个点，也就是这一系列同心椭圆的中心点。因此轮廓图是一种很方便的方法 能够直观地观察代价函数$J$。</p>
<p>接下来让我们看几个例子：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$h_{θ}(x)$ :假设函数</th>
<th style="text-align:center">$J(θ_{1})$ :代价函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(for fixed $θ_{0}$,$θ_{1}$,this is a function of x)</td>
<td style="text-align:center">(function of the parameter $θ_{0}$,$θ_{1}$)</td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/16_07_22/025.png" alt=""></td>
<td style="text-align:center"><img src="/img/16_07_22/026.png" alt=""></td>
</tr>
</tbody>
</table>
<p>在代价函数的图上这一点表示$θ_{0} = 800$，$θ_{1} = -0.15$，坐标为$(800,-0.15)$。而这个点也对应于左边这样一条线，$θ_{0} = 800$也就是跟纵轴相交于大约800，斜率大概是-0.15。当然，这条线并不能很好地拟合数据。并且你也发现了，这个代价值，距离最小值点还很远。也就是说这个代价值还是算比较大的，因此不能很好拟合数据。</p>
<p>让我们再来看另一个假设：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$h_{θ}(x)$ :假设函数</th>
<th style="text-align:center">$J(θ_{1})$ :代价函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(for fixed $θ_{0}$,$θ_{1}$,this is a function of x)</td>
<td style="text-align:center">(function of the parameter $θ_{0}$,$θ_{1}$)</td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/16_07_22/027.png" alt=""></td>
<td style="text-align:center"><img src="/img/16_07_22/028.png" alt=""></td>
</tr>
</tbody>
</table>
<p>你不难发现，这依然不是一个好的拟合，但比刚才稍微好一点。这里$θ_{0} = 360$，$θ_{1} = 0$。因此这组$θ$值对应的假设是:$h(x) = 360 + 0 × x$，这个假设同样也有某个代价值，而这个代价值就对应于这个代价函数在这一点的高度。</p>
<p>让我们再来看另一个例子：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$h_{θ}(x)$ :假设函数</th>
<th style="text-align:center">$J(θ_{1})$ :代价函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(for fixed $θ_{0}$,$θ_{1}$,this is a function of x)</td>
<td style="text-align:center">(function of the parameter $θ_{0}$,$θ_{1}$)</td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/16_07_22/029.png" alt=""></td>
<td style="text-align:center"><img src="/img/16_07_22/030.png" alt=""></td>
</tr>
</tbody>
</table>
<p>这个点其实不是最小值，但已经非常靠近最小值点了。这个点对数据的拟合就很不错。这个点虽然不在最小值点，但非常接近了。因此误差平方和，或者说训练样本和假设的距离的平方和，非常接近于最小值。尽管它还不是最小值。</p>
<p>通过这些图形我希望你能更好地理解这些代价函数$J$所表达的值，它们是什么样的，它们对应的假设是什么样的，以及什么样的假设对应的点更接近于代价函数$J$的最小值。当然我们真正需要的是一种有效的算法，能够自动地找出这些使代价函数$J$取最小值的参数$θ_{0}$和$θ_{1}$来。我想我们也不希望编个程序，把这些点画出来，然后人工的方法来读出这些点的数值。这很明显不是一个好办法。事实上我们后面就会学到，我们会遇到更复杂、更高维度、更多参数的情况，这在我们在后面的视频中很快就会遇到。而这些情况是很难画出图的，因此更无法将其可视化。因此我们真正需要的是编写程序来找出这些最小化代价函数的$θ_{0}$和$θ_{1}$的值。在下一节视频中 我们将介绍一种算法<strong>能够自动地找出能使代价函数$J$最小化的参数$θ_{0}$和$θ_{1}$的值</strong>。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/07/20/斯坦福机器学习课程 第一周 (3)无监督学习/" itemprop="url">
                斯坦福机器学习课程 第一周 (3)无监督学习
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-07-20T12:22:00+08:00" content="2016-07-20">
            2016-07-20
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/机器学习/" itemprop="url" rel="index">
                  <span itemprop="name">机器学习</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/07/20/斯坦福机器学习课程 第一周 (3)无监督学习/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/20/斯坦福机器学习课程 第一周 (3)无监督学习/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="无监督学习">无监督学习</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/olRZo/unsupervised-learning" target="_blank" rel="external">视频地址</a></p>
<p>在这段视频中我们要讲第二种主要的机器学习问题，叫做无监督学习.</p>
<p>在上一节视频中，我们已经讲过了监督学习。回想起上次的数据集，每个样本，都已经被标明为正样本或者负样本，即良性或恶性肿瘤。</p>
<p><img src="/img/16_07_20/001.png" alt=""></p>
<p>因此，对于监督学习中的每一个样本，我们已经被清楚地告知了什么是所谓的正确答案，即它们是良性还是恶性。在无监督学习中，我们用的数据会和监督学习里的看起来有些不一样。在无监督学习中，没有属性或标签这一概念，也就是说所有的数据都是一样的，没有区别。</p>
<p><img src="/img/16_07_20/002.png" alt=""></p>
<p>所以在无监督学习中我们只有一个数据集，没人告诉我们该怎么做，我们也不知道，每个数据点究竟是什么意思。相反，它只告诉我们现在有一个数据集，你能在其中找到某种结构吗？对于给定的数据集，无监督学习算法可能判定该数据集包含两个不同的聚类。</p>
<p>你看，这是第一个聚类。</p>
<p><img src="/img/16_07_20/003.png" alt=""></p>
<p>然后这是另一个聚类。</p>
<p><img src="/img/16_07_20/004.png" alt=""></p>
<p>你猜对了，无监督学习算法会把这些数据分成两个不同的聚类。</p>
<p>所以这就是所谓的聚类算法，实际上它被用在许多地方。</p>
<p>我们来举一个聚类算法的栗子。Google新闻的例子，如果你还没见过这个页面的话，你可以到这个URL <a href="http://news.google.com" target="_blank" rel="external">news.google.com</a>去看看。谷歌新闻每天都在干什么呢？他们每天会去收集成千上万的网络上的新闻，然后将他们分组，组成一个个新闻专题。</p>
<p><img src="/img/16_07_20/005.png" alt=""></p>
<p>比如让我们来看看这里：</p>
<p><img src="/img/16_07_20/006.png" alt=""></p>
<p>这里的URL链接连接着不同的有关BP油井事故的报道。所以让我们点击这些URL中的一个，然后我们会来到这样一个网页。</p>
<p><img src="/img/16_07_20/007.png" alt=""></p>
<p>这是一篇来自华尔街日报的，有关BP油井泄漏事故的报道，标题为《BP杀死了Macondo》。Macondo是个地名，就是那个漏油事故的地方。如果你从这个组里点击一个不同的URL，那么你可能会得到不同的新闻：这里是一则CNN的新闻，是一个有关BP石油泄漏的视频。</p>
<p><img src="/img/16_07_20/008.png" alt=""></p>
<p>如果你再点击第三个链接，又会出现不同的新闻。这边是英国卫报的报道，也是关于BP石油泄漏。</p>
<p><img src="/img/16_07_20/009.png" alt=""></p>
<p>所以，谷歌新闻所做的就是，去搜索成千上万条新闻，然后自动的将他们聚合在一起。因此，有关同一主题的新闻被显示在一起。</p>
<p>实际上聚类算法和无监督学习算法也可以被用于许多其他的问题。这里我们举个它在基因组学中的应用。</p>
<p>下面是一个关于基因芯片的例子，基本的思想是：给定一组不同的个体 对于每个个体，检测它们是否拥有某个特定的基因。也就是说，你要去分析有多少基因显现出来了。因此，这些颜色：红、绿、灰等等，它们 展示了这些不同的个体是否拥有一个特定基因的不同程度。</p>
<p><img src="/img/16_07_20/010.png" alt=""></p>
<p>然后你能做的就是，运行一个聚类算法，把不同的个体归入不同的类或归为不同类型的人。</p>
<p><img src="/img/16_07_20/011.png" alt=""></p>
<p>这就是无监督学习。我们没有提前告知这个算法：这些是第一类的人，这些是第二类的人，这些是第三类的人等等。相反我们只是告诉算法：你看！这儿有一堆数据，我不知道这个数据是什么东东，我不知道里面都有些什么类型，叫什么名字，我甚至不知道都有哪些类型。但是，请问你可以自动的找到这些数据中的类型吗？然后自动的按得到的类型把这些个体分类。虽然事先我并不知道哪些类型。因为对于这些数据样本来说，我们没有给算法一个正确答案，所以，这就是无监督学习。</p>
<p>无监督学习或聚类算法在其他领域也有着大量的应用，它被用来组织大型的计算机集群。</p>
<p>我有一些朋友在管理大型数据中心，也就是大型计算机集群，并试图找出哪些机器趋向于协同工作，如果你把这些机器放在一起，你就可以让你的数据中心更高效地工作。</p>
<p><img src="/img/16_07_20/012.png" alt=""></p>
<p>第二种应用是用于社交网络的分析 </p>
<p>如果可以得知哪些朋友你用email联系的最多，或者知道你的Facebook好友或者你Google+里的朋友，知道了这些之后，我们是否可以自动识别哪些是很要好的朋友组，哪些仅仅是互相认识的朋友组。</p>
<p><img src="/img/16_07_20/013.png" alt=""></p>
<p>还有在市场分割中的应用中，许多公司拥有庞大的客户信息数据库。那么，给你一个客户数据集，你能否自动找出不同的市场分割，并自动将你的客户分到不同的细分市场中，从而有助于我在不同的细分市场中进行更有效的销售。</p>
<p><img src="/img/16_07_20/014.png" alt=""></p>
<p>这也是无监督学习。我们现在有这些客户数据，但我们预先并不知道 有哪些细分市场。而且，对于我们数据集的某个客户，我们也不能预先知道谁属于细分市场一、谁又属于细分市场二等等。但我们必须让这个算法自己去从数据中发现这一切。</p>
<p>最后，事实上无监督学习也被用于天文数据分析。通过这些聚类算法我们发现了许多惊人的、有趣的，以及实用的，关于星系是如何诞生的理论。</p>
<p><img src="/img/16_07_20/015.png" alt=""></p>
<p>所有这些都是聚类算法的例子。而聚类只是无监督学习的一种，现在让我来告诉你另一种，我先来介绍一下鸡尾酒宴问题：</p>
<p>恩，我想你参加过鸡尾酒会的，是吧？嗯，想象一下，有一个宴会，有一屋子的人，大家都坐在一起，而且在同时说话，有许多声音混杂在一起。因为每个人都是在同一时间说话的，在这种情况下你很难听清楚你面前的人说的话。</p>
<p>因此，比如有这样一个场景：宴会上只有两个人，两个人同时说话。恩，这是个很小的鸡尾酒宴会，我们准备好了两个麦克风，把它们放在房间里，然后，因为这两个麦克风距离这两个人的距离是不同的，每个麦克风都记录下了来自两个人的声音的不同组合。也许A的声音在第一个麦克风里的声音会响一点，也许B的声音在第二个麦克风里会比较响一些。因为两个麦克风的位置相对于两个说话者的位置是不同的，但每个麦克风都会录到来自两个说话者的重叠部分的声音。</p>
<p><img src="/img/16_07_20/016.png" alt=""></p>
<p>这里有一个来自一个研究员录下的两个说话者的声音，让我先放给你听。第一个这是第一个麦克风录到的录音： </p>
<p><a href="/audio/16_07_20/001.mp3">Microphone #1</a><br>一 (UNO) 二 (DOS) 三 (TRES) 四 (CUATRO) 五 (CINCO) 六 (SEIS) 七 (SIETE) 八 (ocho) 九 (NUEVE) 十 (Y DIEZ) </p>
<p>好吧 这大概不是什么有趣的酒会…… ……在这个酒会上，有两个人，各自从1数到10。但用的是两种不同语言。你刚才听到的是第一个麦克风的录音，这里是第二个的： </p>
<p><a href="/audio/16_07_20/001.mp3">Microphone #2</a></p>
<p>一 (UNO) 二 (DOS) 三 (TRES) 四 (CUATRO) 五 (CINCO) 六 (SEIS) 七 (SIETE) 八 (ocho) 九 (NUEVE) 十 (Y DIEZ) </p>
<p>所以，我们能做的就是把这两个录音输入一种无监督学习算法中，称为“鸡尾酒会算法”，让这个算法帮你找出其中蕴含的分类，然后这个算法就会去听这些录音，并且你知道这听起​​来像两个音频录音被叠加在一起，所以我们才能听到这样的效果。此外这个算法还会分离出这两个被 叠加到一起的音频源。事实上，这是我们的鸡尾酒会算法的第一个输出：</p>
<p><a href="/audio/16_07_20/003.mp3">Output #1</a> </p>
<p>一 二 三 四 五 六 七 八 九 十 </p>
<p>所以我在一个录音中分离出了英文声音。这是第二个输出：</p>
<p><a href="/audio/16_07_20/002.mp3">Output #2</a></p>
<p>Uno dos tres quatro cinco seis siete ocho nueve y diez </p>
<p>听起来不错嘛。再举一个例子，这是另一个录音，也是在一个类似的场景下，这是第一个麦克风的录音：</p>
<p><a href="/audio/16_07_20/004.mp3">Microphone #1</a></p>
<p> 一 二 三 四 五 六 七 八 九 十 </p>
<p>OK，这个可怜的家伙从鸡尾酒会回家了，他现在独自一人坐在屋里对着录音机自言自语，这是第二个麦克风的录音：</p>
<p><a href="/audio/16_07_20/005.mp3">Microphone #2</a></p>
<p>一 二 三 四 五 六 七 八 九 十 </p>
<p>当你把这两个麦克风录音送给与刚刚相同的算法处理，它所做的还是 告诉你这听起来有两种音频源，并且算法说，这里是我找到的第一个音频源：</p>
<p><a href="/audio/16_07_20/006.mp3">Output #1</a></p>
<p>一 二 三 四 五 六 七 八 九 十 </p>
<p>恩，不是太完美，提取到了人声，但还有一点音乐没有剔除掉。这是算法的第二个输出：</p>
<p><a href="/audio/16_07_20/007.mp3">Output #2</a></p>
<p>还好，在第二个输出中，它设法剔除掉了整个人声，只是清理了下音乐剔除了从一到十的计数。</p>
<p>所以，你可以看到，像这样的无监督学习算法，也许你想问，要实现这样的算法很复杂吧？ 看起来为了构建这个应用程序做这个音频处理似乎需要写好多代码啊，或者需要链接到一堆处理音频的Java库，貌似需要一个非常复杂的程序分离出音频等。</p>
<p>实际上，要实现你刚刚听到的效果，只需要一行代码就可以了。写在这里呢。</p>
<p><img src="/img/16_07_20/017.png" alt=""></p>
<p>当然，研究人员花了很长时间才想出这行代码的^-^，我不是说这是一个简单的问题，但事实上，如果你使用正确的编程环境，许多学习算法是用很短的代码写出来的。所以这也是为什么在这门课中我们要使用Octave的编程环境。</p>
<p>Octave是一个免费的、开放源码的软件。使用Octave或Matlab这类的工具，许多学习算法都可以用几行代码就可以实现。在后续课程中，我会教你如何使用Octave。你会学到如何在Octave中实现这些算法，或者如果你有Matlab，你可以用它。</p>
<p>事实上，在硅谷，很多的机器学习算法，我们都是先用Octave写一个程序原型。因为在Octave中实现这些学习算法的速度快得让你无法想象。</p>
<p>在这里每一个函数，例如：SVD意思是奇异值分解，但这其实是解线性方程的一个惯例，它被内置在Octave软件中了。</p>
<p>如果你试图在C++或Java中做这个，将需要写N多代码，并且还要连接复杂的C++或Java库。所以，你可以在C++或Java或Python中实现这个算法，只是会更加复杂而已。</p>
<p>在教授机器学习将近10年后，我得出的一个经验就是，如果你使用Octave的话，会学的更快。并且如果你用Octave作为你的学习工具 和开发原型的工具，你的学习和开发过程会变得更快。而事实上在硅谷 很多人会这样做。他们会先用Octave来实现这样一个学习算法原型，只有在确定这个算法可以工作后，才开始迁移到C++、Java或其它编译环境。事实证明，这样做实现的算法，比你一开始就用C++实现的算法要快多了。</p>
<p>所以我知道，作为一个老师，我不能老是念叨：“在这个问题上相信我“ 但对于那些从来没有用过这种类似Octave的编程环境的童鞋，我还是要请你相信我这一次，我认为你的时间，研发时间，是你最宝贵的资源之一。</p>
<p>当见过很多的人这样做以后，我觉得如果你也这样做，作为一个机器学习的研究者和开发者，你会更有效率。如果你学会先用Octave开发原型，而不是先用其他的编程语言来开发。</p>
<p>最后，总结一下。这里有一个问题需要你来解答：</p>
<p>我们谈到了无监督学习，它是一种学习机制，你给算法大量的数据，要求它找出数据中蕴含的类型结构，以下的四个例子中，哪一个您认为是 无监督学习算法，而不是监督学习问题？</p>
<ul>
<li>通过标记邮件是否为垃圾邮件来实现的垃圾邮件过滤器。</li>
<li>从网络中爬取一些新闻，按照相同的类别进行自动分组。</li>
<li>通过一个市场数据库，来自动的发现市场细分类别。</li>
<li>通过一系列糖尿病患者的数据信息来学习，达到能分辨一个新的患者是否得了糖尿病。</li>
</ul>
<p>恩，没忘记垃圾邮件文件夹问题吧？如果你已经标记过数据，那么就有垃圾邮件和非垃圾邮件的区别，我们会将此视为一个监督学习问题。</p>
<p>新闻故事的例子正是我们在本课中讲到的谷歌新闻的例子。我们介绍了你可以如何使用聚类算法这些文章聚合在一起，所以这是无监督学习问题。</p>
<p>市场细分的例子，我之前有说过这也是一个无监督学习问题。因为我是要拿到数据，然后要求它自动发现细分市场。</p>
<p>最后一个例子，糖尿病。这实际上就像我们上节课讲到的乳腺癌的例子 只不过这里不是好的或坏的癌细胞，良性或恶性肿瘤。我们现在是有糖尿病或没有糖尿病。所以这是有监督的学习问题，像处理那个乳腺癌的问题一样。我们会把它作为一个有监督的学习问题来处理。</p>
<p>好了，关于无监督学习问题就讲这么多了，下一节课中我们会涉及到更具体的学习算法，并开始讨论这些算法是如何工作的，以及我们如何来实现它们。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/07/19/斯坦福机器学习课程 第一周 (2)监督学习/" itemprop="url">
                斯坦福机器学习课程 第一周 (2)监督学习
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-07-19T10:40:00+08:00" content="2016-07-19">
            2016-07-19
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/机器学习/" itemprop="url" rel="index">
                  <span itemprop="name">机器学习</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/07/19/斯坦福机器学习课程 第一周 (2)监督学习/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/19/斯坦福机器学习课程 第一周 (2)监督学习/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="监督学习">监督学习</h2><p>在本视频中，我将介绍一种也许是最常见的机器学习问题。即监督学习。后面将给出监督学习更正式的定义，现在最好以示例来说明什么是监督学习。之后再给出正式的定义。</p>
<p>假设你想预测房价（无比需要啊！)，之前，某学生已经从某地收集了数据集（不是中国的，囧） 其中一个数据集是这样的。</p>
<p><img src="/img/16_07_19/001.png" alt=""></p>
<p> 这是横坐标，即不同房子的面积，单位平方脚（^-^） 纵轴上是房价，单位 千美元。 根据给定数据，假设你朋友有栋房子，750平尺（70平米） 想知道这房子能卖多少，好卖掉。 那么，学习算法怎么帮你呢？学习算法可以： 绘出一条直线，让直线尽可能匹配到所有数据。 </p>
<p><img src="/img/16_07_19/002.png" alt=""></p>
<p>基于此，看上去，那个房子应该、可能、也许、大概 卖到15万美元（一平米两千刀！）。但这不是唯一的学习算法。可能还有更好的。比如不用直线了，可能平方函数会更好，即二次多项式更符合数据集。如果你这样做，预测结果就应该是20万刀（一平三千刀，涨价好快）。</p>
<p><img src="/img/16_07_19/003.png" alt=""></p>
<p>后面我们会介绍到如何选择，是选择直线还是平方函数来拟合。没有明确的选择，就不知哪个能给你的朋友更好的卖房建议。只是这些每个都是很好的学习算法例子。也是监督学习的例子。术语监督学习，意指给出一个算法，需要部分数据集已经有正确答案。比如给定房价数据集， 对于里面每个数据，算法都知道对应的正确房价，即这房子实际卖出的价格。算法的结果就是算出更多的正确价格，比如那个新房子，你朋友想卖的那个。</p>
<p>用更术语的方式来定义，监督学习又叫回归问题，（应该是回归属于监督中的一种）意指要预测一个连续值的输出，比如房价。虽然从技术上，一般把房价记到美分单位。所以实际还是个离散值，但通常把它看作实际数字，是一个标量值，一个连续值的数，而术语回归，意味着要预测这类连续值属性的种类。另一个监督学习的例子，我和一些朋友 之前研究的领域。让我们来看医学记录，并预测胸部肿瘤是恶性良性。 如果某人发现有胸部肿瘤，恶性肿瘤有害又危险，良性肿瘤则是少害。 显然人们很关注这个。让我们看一个收集好的数据集，假设在数据集中，横轴表示肿瘤的大小，纵轴我打算圈上0或1，是或否，即肿瘤是恶性的还是良性的。</p>
<p><img src="/img/16_07_19/004.png" alt=""></p>
<p>所以如图所示，可以看到这个大小的肿瘤块 是良性的，还有这些大小的都是良性的。 不幸地是也看到一些恶性肿瘤，比如这些大小的肿瘤。 所以，有5个良性块，在这一块，还有5个恶性的，它们纵轴值为1。</p>
<p>现在假设某人杯具地得胸部肿瘤了，大小大概是这么大。</p>
<p><img src="/img/16_07_19/005.png" alt=""></p>
<p>对应的机器学习问题就是，你能否估算出一个概率，即肿瘤为恶或为良的概率？ 专业地说，这是个分类问题。分类是要预测一个离散值输出。这里是0或1，恶性或良性。</p>
<p>事实证明，在分类问题中，有时会有超过两个的值，输出的值可能超过两种。举个具体例子，胸部肿瘤可能有三种类型，所以要预测离散值0，1，2，3。假设总共有三种癌症。0就是良性肿瘤，没有癌症。1 表示1号癌症，2 是2号癌症，3 就是3号癌症。这同样是个分类问题，因为它的输出的离散值集合 分别对应于无癌，1号，2号，3号癌症。</p>
<p>我再露一小手，在分类问题中，还有另一种作图方式 来描述数据。我画你猜。要用到些许不同的符号集合 来描绘数据。如果肿瘤大小作为唯一属性，被用于预测恶性良性，可以把数据作图成这样。</p>
<p><img src="/img/16_07_19/006.png" alt=""></p>
<p>使用不同的符号来表示良性和恶性，即阴性和阳性。所以，不再统一画叉叉了，改用圈圈来代表良性肿瘤，就像这样。仍沿用X（叉叉）代表恶性肿瘤。希望你能明白。我所做的就是，把在上面的数据， 映射下来。再用不同的符号， 圈和叉来分别代表良性和恶性。</p>
<p>在上例中，只使用了一个特征属性，即肿瘤块大小，来预测肿瘤是恶性良性。在其它机器学习问题里，有着不只一个的特征和属性。</p>
<p>例子，现在不只是知道肿瘤大小，病人年龄和肿瘤大小都知道了。</p>
<p><img src="/img/16_07_19/007.png" alt=""></p>
<p>这种情况下，数据集如表图所示，有些病人，年龄、肿瘤已知，不同的病人，会有一点不一样，肿瘤恶性，则用叉来代表。所以，假设 有一朋友得了肿瘤。肿瘤大小和年龄落在此处。</p>
<p><img src="/img/16_07_19/008.png" alt=""></p>
<p>那么依据这个给定的数据集，学习算法所做的就是画一条直线，分开 恶性肿瘤和良性肿瘤，所以学习算法会画条直线，像这样，把两类肿瘤分开。</p>
<p><img src="/img/16_07_19/009.png" alt=""></p>
<p>然后你就能判断你朋友的肿瘤是…了。如果它在那边，学习算法就说 你朋友的肿瘤在良性一边，因此更可能是良性的。</p>
<p><img src="/img/16_07_19/010.png" alt=""></p>
<p>好，本例中，总共有两个特征，即病人年龄和肿瘤大小。在别的ML问题中， 经常会用到更多特征，我朋友研究这个问题时，通常使用这些特征：比如块的厚度，即胸部肿瘤的厚度、肿瘤细胞大小和形状的一致性，等等。它表明，最有趣的学习算法（本课中将学到） 能够处理，无穷多个特征。不是3到5个这么少。在这张幻灯片中，我已经列举了总共5个不同的特征。但对于一些学习问题，真要用到的不只是三五个特征，要用到无数多个特征，非常多的属性，所以，你的学习算法要使用很多的属性或特征、线索来进行预测。那么，你如何处理 无限多特征呢？甚至你如何存储无数的东西进电脑里，又要避免内存不足？</p>
<p>事实上，等我们介绍一种叫<strong>支持向量机（SVM）</strong>的算法时，就知道存在一个简洁的数学方法，能让电脑处理无限多的特征。想像下，我不是这边写两个特征，右边写三个特征。而是，写一个无限长的特征表，不停地写特征，似乎是个无限长的特征的表。但是，我们也有能力设计一个算法来处理这个问题。</p>
<p>所以再从头复述一遍。本课中，我们介绍监督学习。其基本思想是，监督学习中，对于数据集中的每个数据，都有相应的正确答案，（训练集）算法就是基于这些来做出预测。就像那个房价，或肿瘤的性质。后面介绍了回归问题。即通过回归来预测一个连续值输出。我们还谈到了分类问题，目标是预测离散值输出。</p>
<p>下面是个小测验题目：假设你有家公司，希望研究相应的学习算法去 解决两个问题。</p>
<p>第一个问题，你有一堆货物的清单。 假设一些货物有几千件可卖，你想预测出，你能在未来三个月卖出多少货物。 </p>
<p>第二个问题，你有很多用户， 你打算写程序来检查每个用户的帐目。 对每个用户的帐目，判断这个帐目是否被黑过（hacked or compromised）。</p>
<p>问题一是个回归问题 因为如果我有几千件货物， 可能只好把它当作一个实际的值，一个连续的值。也把卖出的数量当作连续值。</p>
<p>第二个问题，则是分类问题，因为可以把我想预测的一个值设为0，来表示账目没有被hacked另一个设为1，表示已经被hacked。 就像乳癌例子中，0表示良性，1表示恶性。 所以这个值为0或1，取决于是否被hacked，有算法能预测出是这两个离散值中的哪个。 因为只有少量的离散值，所以这个就是个分类问题。 这就是监督学习，下个视频将会介绍 无监督学习，学习算法的另一主要类型。 </p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/07/19/斯坦福机器学习课程 第一周 (1)欢迎来到机器学习/" itemprop="url">
                斯坦福机器学习课程 第一周 (1)欢迎来到机器学习
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-07-19T10:16:00+08:00" content="2016-07-19">
            2016-07-19
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/机器学习/" itemprop="url" rel="index">
                  <span itemprop="name">机器学习</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/07/19/斯坦福机器学习课程 第一周 (1)欢迎来到机器学习/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/19/斯坦福机器学习课程 第一周 (1)欢迎来到机器学习/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="欢迎来到机器学习">欢迎来到机器学习</h2><p>欢迎来到这门关于机器学习的免费网络课程。机器学习是近年来最激动人心的技术之一。在这门课中，你不仅可以了解机器学习的原理，更有机会进行实践操作，并且亲自运用所学的算法。在生活中，每天你都可能在不知不觉中使用了各种各样的机器学习算法。比如，当你每一次使用像诸如谷歌 (Google)或必应 (Bing) 的搜索引擎时，它们运作得如此之好的原因之一便是，由Google或微软实现的一种学习算法可以“学会”如何对网页进行排名；每当你使用脸书 (Facebook)或苹果 (Apple) 的照片处理应用时，它们都能自动识别出你朋友的照片，这也是机器学习的一种；每当你阅读电子邮件时，你的垃圾邮件过滤器帮你免受大量垃圾邮件的困扰，这也是通过一种学习算法实现的。还有一个让我兴奋的理由，是一个关于人工智能的梦想：有朝一日，我们能创造出像你我一样聪明的机器，尽管我们离这个目标仍有很长的距离，但许多的人工智能专家相信，实现这一目标最好的途径是通过学习算法，来模拟人类大脑的学习方式。关于这点，我也会在这门课程中有所提及。</p>
<p>在这门课中你将会掌握机器学习的前沿原理。但是，仅仅了解其中的算法和数学是不够的。尤其是如果你并不知道如何将所学的理论知识用到你的实际问题上时。因此，我们也将花费大量时间来让大家进行编程练习，帮助你实现所学的算法，并体验到它们究竟是怎么运作的。</p>
<p>话说，为什么机器学习在当今如此流行呢？ 机器学习发源于人工智能领域 我们希望能够创造出具有智慧的机器。我们通过编程来让机器完成一些基础的工作，比如如何找到从A到B的最短路径，但在大多数情况下，我们并不知道如何显式地编写人工智能程序，来做一些更有趣的任务。比如网页搜索，标记照片和拦截垃圾邮件等。人们意识到唯一能够达成这些目标的方法，就是让机器自己学会如何去做。因而，机器学习已经发展成为计算机的一项新能力，并且与工业界和基础科学界有着紧密的联系。</p>
<p>身处机器学习领域。我常常会在短短一周中与形形色色的人打交道 如直升机飞行员、生物学家、还有许多计算机系统专家。比如我在斯坦福的同事们，同时平均每周我还会数次收到来自硅谷的业界人士的email，咨询我是否有兴趣将机器学习算法应用到他们所遇到的实际问题中，以上的例子都彰显了机器学习所能处理的问题范围之广。在硅谷，机器学习引导着大量的课题。如自主机器人、计算生物学等。机器学习的实例还有很多，比如数据库挖掘。机器学习变得如此流行的原因之一，便是网络和自动化算法的爆炸性增长，这意味着我们掌握了比以往多得多的数据集。举例来说，当今有数不胜数的硅谷企业，在收集有关网络点击的数据 (Clickstream Data) 并试图在这些数据上运用机器学习的算法来更好的理解和服务用户，这在硅谷已经成为了一项巨大的产业。随着电子自动化的发展，我们现在拥有了电子医疗记录，如果我们能够将这些记录转变为医学知识，那我们就能对各种疾病了解的更深入，同时，计算生物学也在电子自动化的辅助下快速发展。生物学家收集了大量有关基因序列以及DNA序列的数据，通过对其应用机器学习的算法来帮助我们跟深入地理解人类基因组，及其对我们人类的意义，几乎工程界的所有领域，都在使用机器学习算法来分析日益增长的海量数据集。有些机器应用我们并不能够通过手工编程来实现，比如说，我个人对自动直升机有着许多年的研究，想要写出一个能让直升机自主飞行的程序几乎是不可能的任务。唯一可行的解决方案就是让一台计算机能够自主地学会如何让直升机飞行。再比如手写识别，如今将大量的邮件，按地址分类寄送到全美甚至全球的代价大大降低，其中重要的理由之一便是每当你写下这样一封信时 一个机器学习的算法已经学会如何读懂你的笔迹并自动地将你的信件发往它的目的地.所以邮寄跨越上万里的信件的费用也很低。你也许曾经接触过自然语言处理和计算机视觉，事实上，这些领域都是试图通过人工智能来理解人类的语言和图像，如今大多数的自然语言处理和计算机视觉都是对机器学习的一种应用。</p>
<p>机器学习算法也在用户自定制化程序(self-customizing program)中有着广泛的应用，每当你使用亚马逊、Netflix或iTunes Genius的服务时，都会收到它们为你量身推荐的电影或产品。这就是通过学习算法来实现的。可以相信，这些应用都有着上千万的用户，而针对这些海量的用户编写千万个不同的程序显然是不可能的。唯一有效的解决方案就是开发出能够自我学习，定制出符合你喜好的并据此进行推荐的软件，最后，机器学习算法已经被应用于探究人类的学习方式，并试图理解人类的大脑。我们也将会了解到研究者是如何运用机器学习的工具，来一步步实现人工智能的梦想。</p>
<p>就在几个月前我的一位学生给我看了一篇文章，文中列举了当今12个最主要的IT技能，这些技术可以让信息技术行业的招聘官无法拒绝你。虽然这是一篇略显老旧的文章，但所有技能中最重要的便是机器学习。在斯坦福，向我咨询有没有即将毕业的研究机器学习学生的雇主，远远多于我们这儿每年毕业的机器学习的学生。因而我觉得对机器学习这一技能的需求仍有着巨大的缺口，而现在正是学习它的绝佳机会。我希望你们能在这门课中收获良多。在接下来的视频中，我将更正式地定义什么是机器学习，也会讨论机器学习主要面对的几类问题和相关算法，你也会学习一些主要的机器学习术语，并对不同的算法和其适用的场景有初步的了解。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/07/13/gradle学习笔记-持续构建/" itemprop="url">
                gradle学习笔记-持续构建
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-07-13T22:06:55+08:00" content="2016-07-13">
            2016-07-13
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/gradle/" itemprop="url" rel="index">
                  <span itemprop="name">gradle</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/07/13/gradle学习笔记-持续构建/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/13/gradle学习笔记-持续构建/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>持续构建是一个正在发<strong>孵化中(<a href="https://docs.gradle.org/current/userguide/feature_lifecycle.html" target="_blank" rel="external">incubating</a>)</strong>的feature。这意味着它目前还是不完整的，并且没有达到gradle产品的标准。这同样也意味着这一章节的用户指南也是在不断完善中的。</p>
</blockquote>
<p>通常，你让gradle执行一个你指定task。gradle需要制定一系列实际需要执行的满足要求的task，并将它们全部执行，然后停止工作直到下一次请求出现。持续构建不同于gradle那种通过在检查到之前的构建已经过时时执行构建，来保持满足初始化构建的条件（直到指示停止）。例如：如果你将java代码编译为class文件，一个持续构建将在源码文件改变时自动初始化一次编译。持续构建在很多场景下都很有用。</p>
<h2 id="1-我该如何开始和终止一个持续构建呢？">1.我该如何开始和终止一个持续构建呢？</h2><p>一个持续构建可以通过输入<code>--continuous</code>或<code>-t</code>开关来开启，通过对任务列表中的任务切换开关和参数，来定义要执行的任务。例如：<code>gradle build --continuous</code>。这和执行<code>gradle build</code>的效果是一样的，但当gradle执行完时，它会等待发生改变的文件输入。当有改变产生时，<code>gradle build</code>将会被再次自动的执行，再次执行构建。</p>
<p>如果gradle附加在了一个交互式输入源，例如终端，持续构建会在按下<strong>CTRL-D</strong>（在Microsoft Windows上，在按下<strong>CTRL-D</strong>之后还需要按下<strong>ENTER</strong>或者<strong>RETURN</strong>）时执行。如果gradle没有附加在交互式输入源(例如以一个脚本的形式运行)，构建进程一定需要被中断（使用<code>kill</code>命令或类似的其他方式）。如果构建是通过Tooling API执行的，构建可以通过Tooling API的取消机制来终止。</p>
<h2 id="2-什么将会导致后续的构建？">2.什么将会导致后续的构建？</h2><p>这时，只有对task输入的更改会被注意到。gradle会在task开始时就对改变进行监控。没有其他的改变会初始化一次构建。例如：对于构建脚本和构建逻辑的修改不会初始化构建。同样的，对于修改配置文件在构建时读入的文件，没有执行，将不会初始化一次构建。为了纳入这种变化，持续构建必须手动重启。</p>
<p>对于一个典型的使用java插件的构建，使用传统的文件系统布局。下面是<code>gradle build</code>的生词的task图。</p>
<p><strong>Java plugin task graph</strong></p>
<p><img src="/img/16_07_13/javaPluginTasks.png" alt=""></p>
<p>下面对于图中用到的task使用相对路径作为输入：</p>
<p><strong>compileJava</strong></p>
<pre><code>src<span class="regexp">/main/</span>java
</code></pre><p><strong>processResources</strong></p>
<pre><code>src<span class="regexp">/main/</span>resources
</code></pre><p><strong>compileTestJava</strong></p>
<pre><code>src/<span class="built_in">test</span>/java
</code></pre><p><strong>processTestResources</strong></p>
<pre><code>src/<span class="built_in">test</span>/resources
</code></pre><p>假设初始化构建执行成功（比如：构建task和它的依赖的编译都没有错误），对文件的更改，或者对文件的增删操作，上述的场景将会初始化一次构建。如果在<code>src/main/java</code>目录下的java代码发生了变动，构建将会启动，并且所有的task将开始执行。gradle的增量构建支持，确保只有被变动所影响的task会被执行。</p>
<p>如果主项目中的java代码编译失败，那么子变动<code>src/test/java</code>目录将不会被执行构建。由于测试代码依赖于主代码，直到主代码发生了改变，才有可能修复编译产生的错误。在每次构建之后，只有task的输入文件会被检测变化。</p>
<h2 id="3-限制和异常">3.限制和异常</h2><p>目前有几个关于持续构建的问题。这些问题有可能会在未来的gradle版本中进行修复。</p>
<h3 id="3-1_构建循环">3.1 构建循环</h3><p>gradle会在task执行之前就去监测改变。如果一个task在执行过程中改变了它自己，gradle将会查出这个变动，并且触发一次新的构建。如果每次task的执行，输入都被改变，那么构建就会再一次被触发。这不仅仅在持续构建中会出问题。当在“normally”模式并不是持续构建模式下运行，task改变了他自身的输入时也不会被视为有“up-to-date”标签。</p>
<p>如果你的构建进入了一个这样的循环，你可以通过gradle的查看报告清单中的变动追踪task。当确认有文件在每次构建期间发生了改变，你应该找到那个出问题的task。在某些情况下，这种问题会很明显（例如：java文件通过<code>compileJava</code>来执行编译）。在其他的情况下，你可以通过使用<code>--info logging</code>来找到识别为<code>out-of-date</code>的文件所在的task。</p>
<h3 id="3-2_需要Java7或更高版本">3.2 需要Java7或更高版本</h3><p>gradle使用jdk的<a href="http://docs.oracle.com/javase/7/docs/api/java/nio/file/WatchService.html" target="_blank" rel="external">WatchService</a>来在每次构建之间接收文件改变的通知。这个API是在Java7中引进的。由于这个原因，gradle的持续构建暂时不支持在Java6下的构建。</p>
<h3 id="3-3_性能和稳定性">3.3 性能和稳定性</h3><p>Jdk文件监控设备在 Mac OS X（见<a href="https://bugs.openjdk.java.net/browse/JDK-8079620" target="_blank" rel="external">JDK-8079620</a>）上会依赖于一个无效的文件系统。这在大型项目中能感受到通知改变有显著的延迟。</p>
<p>此外，监控机制可能在 Mac OS X （见<a href="https://bugs.openjdk.java.net/browse/JDK-8079620" target="_blank" rel="external">JDK-8079620</a>）下进行<strong>超负荷</strong>的加载时发生死锁。这表明，gradle不会通知文件改变。如果你怀疑这种情况发生了，退出持续构建，并且重新启动。</p>
<p>在Linux下，OpenJDK的文件检测服务有时会丢失一些系统事件（见：<a href="https://bugs.openjdk.java.net/browse/JDK-8145981" target="_blank" rel="external">JDK-8145981</a>）。</p>
<h3 id="3-4_符号链接的更改">3.4 符号链接的更改</h3><ul>
<li>创建或删除符号链接到文件将启动一次构建。</li>
<li>修改一个符号链接的目标不会导致重建。</li>
<li>创建或删除符号链接目录不会造成重建。</li>
<li>在一个符号链接的目标目录中创建新文件将不会导致重建。</li>
<li>删除目标目录将不会导致重建。</li>
</ul>
<h3 id="3-5_不考虑构建逻辑的更改">3.5 不考虑构建逻辑的更改</h3><p>当前的实现是在不会重新计算构建模型。这意味着对task配置的更改，或者其他对构建modle的改动，都是被忽略的。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/07/11/gradle学习笔记-多项目构建介绍/" itemprop="url">
                gradle学习笔记-多项目构建介绍
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-07-11T23:06:55+08:00" content="2016-07-11">
            2016-07-11
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/gradle/" itemprop="url" rel="index">
                  <span itemprop="name">gradle</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/07/11/gradle学习笔记-多项目构建介绍/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/11/gradle学习笔记-多项目构建介绍/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>只有小规模的项目具有单一的构建文件和源码，除非恰好是一个大规模的整体的应用。项目被分割成更小的、相互依赖的模块，往往会更容易理解和处理。“相互依赖”这个词很重要，因此，这就是为什么你通常希望通过一个单一的构建将多个模块链接起来。</p>
<p>gradle通过<strong>多项目构建(multi-project)</strong>来支持这种需求。</p>
<h2 id="1-多项目构建的结构">1.多项目构建的结构</h2><p>这种构建引入了各种各样的子项目，但它们都有共同的特点：</p>
<ul>
<li>在项目的根目录都有一个<code>settings.gradle</code>文件</li>
<li>在根目录或主目录下都有一个<code>build.gradle</code>文件</li>
<li>每个字目录都有他们自己的<code>*.gradle</code>文件（有些多项目构建结构也许会胜率子项目的构建脚本）</li>
</ul>
<p><code>settings.gradle</code>告诉gradle主项目和子项目的结构是怎样的。幸运的是，你其实不必通过读这个文件来了解项目的结构是怎样，如果你想要了解项目结构的话，通过运行命令<code>gradle projects</code>就可以了。下面是一个在<strong>多项目(multiproject)</strong>下使用命令的例子：</p>
<p><strong>列出一次构建中的项目</strong></p>
<p>gradle -q projects</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt; gradle -q projects</div><div class="line"></div><div class="line">------------------------------------------------------------</div><div class="line">Root <span class="keyword">project</span></div><div class="line">------------------------------------------------------------</div><div class="line"></div><div class="line">Root <span class="keyword">project</span> <span class="string">'multiproject'</span></div><div class="line">+--- <span class="keyword">Project</span> <span class="string">':api'</span></div><div class="line">+--- <span class="keyword">Project</span> <span class="string">':services'</span></div><div class="line">|    +--- <span class="keyword">Project</span> <span class="string">':services:shared'</span></div><div class="line">|    \--- <span class="keyword">Project</span> <span class="string">':services:webservice'</span></div><div class="line">\--- <span class="keyword">Project</span> <span class="string">':shared'</span></div><div class="line"></div><div class="line">To see a list of the tasks of a <span class="keyword">project</span>, run gradle &lt;<span class="keyword">project</span>-path&gt;:tasks</div><div class="line"><span class="keyword">For</span> example, <span class="keyword">try</span> running gradle :api:tasks</div></pre></td></tr></table></figure>
<p>输出结果会告诉你，这个多项目构建有三个直接的子项目：<strong>api</strong>，<strong>services</strong>和<strong>shared</strong>。其中<strong>services</strong>还有属于它的子项目:<strong>shared</strong>和<strong>webservice</strong>。通过这个目录结构图，我们可以很容易的找到任意一个其中的项目。例如：你可以通过这张图中发现<strong>webservice</strong>位于<code>&lt;root&gt;/services/webservice.</code>这个位置。</p>
<p>默认情况下，gradle使用<code>settings.gradle</code>文件的目录名来作为根项目的名称。这样做通常不会有什么问题，因为所有的开发者会在同一个项目中检出相同的目录名。在持续集成服务器上，例如Jenkins，目录名称可能会是自动生成的并且与你的版本控制工具中的名字并不匹配。因此，建议你设置一个可预测的项目名称，即使是一个单一构建的项目。你可以通过设置<code>rootProject.name</code>来配置根项目名。</p>
<p>每个项目都有属于它们自己的构建文件，但这并不是必须的。在上面的例子中，<strong>services</strong>项目仅仅是其他子项目的一个容器或者说是分组。在它相应的目录中没有构建文件。然而，多构建项目的根项目都有这个构建文件。</p>
<p>根项目的<code>build.gradle</code>通常会和子项目共享配置，例如主项目会和子项目共享自己的插件和依赖项。当所有的配置都在同一个地方，也可以通过配置这一处来达到配置所有子项目的效果。这意味着，当你发现某个子项目被配置了某个属性，你通常应该先经常检查根项目的构建文件。</p>
<p>另外一个需要被牢记的是构建配置的文件可能并不叫<code>build.gradle</code>。许多项目都会以子项目的名称来命名构建文件，例如之前例子中的<code>api.gradle</code>和<code>services.gradle</code>。在使用IDE时，这种做法有很大的好处，因为很难从几十个<code>build.gradle</code>文件中找出你要的具体是哪一个。对于<code>settings.gradle</code>文件的处理有一点小小的特殊，但对于一次构建，你不需要了解它是怎么做到这样的。只需要看一看子项目目录，去找一下以<code>.gradle</code>结尾的文件就行了。</p>
<p>一旦你知道子项目中能用到的是什么，那么关键的问题就是构建者如何在项目中执行这些task。</p>
<h2 id="2-执行一个多项目构建">2.执行一个多项目构建</h2><p>从用户的角度去看，多项目构建任然是一系列可以用来运行的task。这不同于你想控制哪一个项目的task的执行。这里你有两条选项：</p>
<ul>
<li>改变子项目对应的目录到你想要的地方，然后正常的执行<code>gradle &lt;task&gt;</code>。</li>
<li>在任意目录下都使用一个符合标准的task的名称，尽管这通常是从根目录开始的。例如：<code>gradle :services:webservice:build</code>将执行<strong><code>webservice</code></strong>这个子项目以及它所依赖的所有子项目。</li>
</ul>
<p>第一种方法是类似于单项目的使用情况，但在多项目的gradle构建时略有不同。命令<code>gradle test</code>会执行相对于当前工作目录的所有子项目中的test task，前提是如果这些子项目中有这个名为<code>test</code>的task。因此，如果你在根项目的目录下运行命令，你也会在<strong>api</strong>, <strong>shared</strong>, <strong>services:shared</strong> 和<strong>services:webservice</strong>下运行test这个task。如果你仅仅在<strong>services</strong>这个项目下运行这个命令，那么只有<strong> services:shared</strong>和<strong>services:webservice</strong>这两个项目会执行test的task。</p>
<p>为了能更多的控制执行，可以使用符合标准的名字（上面提到的第二种方法）。这些路径类似于目录路径，但需要使用”:”而不是”/“或”\”。如果路径是以”:”开头的，那么路径会以根项目为相对路径去解析。换句话说，开头的”:”代表根项目本身。所有其他的冒号都是路径分隔符。</p>
<p>这种方法适用于任何task，所以，如果你想知道在一个特定的子项目的task是什么，只需使用类似这种方式：<code>gradle :services:webservice:tasks</code>。</p>
<p>无论你使用哪种方式来执行task，gradle都能处理好当前依赖的任何子项目的构建。你不用担心项目间依赖问题。如果你对它们是如何配置的感兴趣，你可以阅读写多项目构建的文档<a href="https://docs.gradle.org/current/userguide/multi_project_builds.html" target="_blank" rel="external">later in the user guide</a>。</p>
<p>还有最后一件事要注意。当你使用gradle wrapper时，第一种方式不能很好的工作，因为如果你不在项目的根目录，你必须对你的wrapper脚本指定路径。举个例子：如果你在<strong>webservice</strong>这个子项目中，你必须执行<code>../../gradlew build</code></p>
<p>这就是构建者关于多项目构建需要了解的全部。现在你可以辨别一个构建是否是一个多项目构建项目，并且可以观察它的结构。最终你可以执行指定的子项目的task。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/07/11/gradle学习笔记-依赖管理基础/" itemprop="url">
                gradle学习笔记-依赖管理基础
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-07-11T15:06:55+08:00" content="2016-07-11">
            2016-07-11
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/gradle/" itemprop="url" rel="index">
                  <span itemprop="name">gradle</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/07/11/gradle学习笔记-依赖管理基础/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/11/gradle学习笔记-依赖管理基础/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>这一节将介绍一些gradle中依赖管理的基本知识。</p>
<h2 id="1-什么是依赖管理？">1.什么是依赖管理？</h2><p>粗略的说，依赖管理是由两个部分组成的。首先，gradle需要知道你的项目需要执行的一些构建和一些运行的信息，通过这些信息可以找到它们。我们称这些传入的文件为项目的<strong>依赖（dependencies）</strong>。第二，Gradle需要构建和上传您的项目产生的东西。我们把这些传出的文件称为项目的<strong>出版物（publications）</strong>。让我们更详细地看一下这两部分：</p>
<p>大多数项目并不是完全独立的。它们需要其他项目构建的文件以便于被编译或测试，等。例如，为了在我的项目中使用Hibernate,我需要在编译我的源代码时引入一些Hibernate的jar包到classpath中。为了运行我的测试，我也许需要引入一些额外的jar包到test的classpath中，例如一个特定的JDBC驱动，或者Ehcache jar包。</p>
<p>这些传入的文件形成了项目的依赖关系。gradle允许你告诉它你的项目依赖是怎样的，这样以来它可以照顾好你的项目依赖关系，并且在你的构建中也是可以生效的。依赖可能需要从远程仓库Maven、lvy下载到本地，或者也有可能存在于本地目录，或者也许是同一个多项目构建的项目中的一个其他项目。我们称这个过程为<strong>依赖解析(dependency resolution)</strong>。</p>
<p>请注意，这里提到的这个主要功能的优势超越了Ant。用Ant时，你只能通过指定jar包加载的绝对路径或相对路径。然而在使用gradle时，你只需要简单的声明依赖的“名字”，以及指定其他层是从哪里获得这些依赖的即可。你可以通过在Ant上添加Apache lvy来简化这些操作，但gradle会处理的更好。</p>
<p>通常，一个项目的依赖，其自身也存在依赖。例如，Hibernate内核需要添加几个其他的库到classpath中，才能正常运行。因此，当gradle在你的项目中运行测试，也需要去找到它的依赖项并且确保它们是可用的。我们称这种为<strong>过渡依赖(transitive dependencies)</strong>。</p>
<p>很多项目就是为了让外部项目来使用的。例如，如果你的项目提供一个java库，你需要构建一个jar包，并且可能是源码jar以及一些文档，并将它们发布到某个地方。</p>
<p>这些发出来的文件形成了这些项目的出版物。gradle也会做好这些工作的。你声明你的项目的出版物，然后gradle会负责构建并将它们发布到某个地方。究竟“发布（publishing）”是什么意思，取决于你具体想怎么做。也许你只是想从本地目录拷贝文件，或者上传它们到一个远端的Maven或lvy仓库，或者你使用的文件是当前项目中多个子项目中的另一个子项目中的。我们称这种行为是<strong>发布(publishing)</strong>。</p>
<h2 id="2-声明你的依赖">2.声明你的依赖</h2><p>让我们来看看一些依赖的声明。这是一个基本构建脚本：</p>
<p><strong>声明依赖</strong></p>
<p>build.gradle</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></div><div class="line"></div><div class="line">repositories &#123;</div><div class="line">    mavenCentral()</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    compile <span class="string">group:</span> <span class="string">'org.hibernate'</span>, <span class="string">name:</span> <span class="string">'hibernate-core'</span>, <span class="string">version:</span> <span class="string">'3.6.7.Final'</span></div><div class="line">    testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.+'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些是什么呢？这些构建脚本描述了一些项目的事情。首先，规定了编译项目源码需要用到版本为“3.6.7.Final”的Hibernate core。言外之意，Hibernate core和它自身的依赖项也将在运行时被使用到。这个构建脚本也指出编译项目的测试，需要任意版本&gt;=4.0的junit。这也是再告诉gradle去看看Maven中央仓库里是否有其他的依赖被用到。下面我们详细来介绍一下。</p>
<h2 id="3-依赖配置">3.依赖配置</h2><p>在gradle中依赖是在设置中分组配置的。一个配置是一个被命名的一系列依赖项。我们把它们称为依赖配置。您可以使用它们来声明项目的外部依赖关系。我们稍后也会看到，他们会被用来申报你的项目的publications。</p>
<p>java插件定义了大量的标准配置。这些配置表示java插件使用到的classpath。一些已经列在下面，你可以在<a href="https://docs.gradle.org/current/userguide/java_plugin.html#tab:configurations" target="_blank" rel="external">Table 45.5, “Java plugin - dependency configurations”</a>看到更多的详细信息。</p>
<ul>
<li><p><strong>compile</strong></p>
<p>  编译项目所需要的依赖</p>
</li>
<li><p><strong>runtime</strong></p>
<p>  项目运行所需要的依赖。默认情况下，也包含编译时的依赖。</p>
</li>
<li><p><strong>testCompile</strong></p>
<p>  项目测试是所需要的依赖。默认情况下，也包含已编译的项目的类和编译时依赖。</p>
</li>
<li><p><strong>testRuntime</strong></p>
<p>  运行测试所需的依赖关系。默认情况下，包含编译、运行时和测试编译所需要的依赖。</p>
</li>
</ul>
<p>各种插件添加更多的配置。你也可以在你的构建中使用自定义配置。关于定义和定制依赖的设置，详情请见<a href="https://docs.gradle.org/current/userguide/dependency_management.html#sub:configurations" target="_blank" rel="external">Section 23.3, “Dependency configurations</a></p>
<h2 id="4-外部依赖">4.外部依赖</h2><p>你可以声明各种各样的依赖类型。一类是<strong>外部依赖(external dependency)</strong>。这是一些依赖于非当前构建的外部文件，这些文件存储在某个外部库中，如Maven中央仓库、公司级Maven、lvy库，或本地的目录。</p>
<p>如果要定义一个外部依赖关系，您需要将它添加到依赖配置中：</p>
<p><strong>外部依赖的定义</strong></p>
<p>build.gradle</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">dependencies</span> &#123;    compile <span class="attribute">group</span>:<span class="string">'org.hibernate'</span>, <span class="attribute">name</span>:<span class="string">'hibernate-core'</span>, <span class="attribute">version</span>:<span class="string">'3.6.7.Final'</span>&#125;</div></pre></td></tr></table></figure>
<p>一个外部依赖是通过组名，库名，以及版本号来唯一标示的。其中组名和版本号是可选的。</p>
<p>也可以使用类似于：<code>&quot;group:name:version&quot;</code>的简写形式。</p>
<p><strong>外部依赖定义的简写形式</strong></p>
<p>build.gradle</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">dependencies</span> &#123;    <span class="keyword">compile</span><span class="string">'org.hibernate:hibernate-core:3.6.7.Final'</span>&#125;</div></pre></td></tr></table></figure>
<p>更多关于依赖的定义和使用，见<a href="https://docs.gradle.org/current/userguide/dependency_management.html#sec:how_to_declare_your_dependencies" target="_blank" rel="external">Section 23.4, “How to declare your dependencies”</a>。</p>
<h2 id="5-仓库">5.仓库</h2><p>gradle是如何找到外部依赖的文件的呢？gradle通过在一个<strong>仓库repository</strong>中寻找这些文件。一个仓库其实就是一个通过组名，文件名和版本号标识的文件集合。gradle能理解几种不同的仓库格式，例如Maven，lvy，以及几种不同的方式访问仓库，如本地文件系统或者http。</p>
<p>默认情况下，gradle并没有定义任何仓库。在你使用外部依赖之前你需要定义至少一个仓库。一种可选的方案是使用Maven中央仓库：</p>
<p><strong>使用Maven中央仓库</strong></p>
<p>build.gradle</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class">repositories </span>&#123;</div><div class="line">    mavenCentral()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者是JCenter</p>
<p><strong>使用JCenter仓库</strong></p>
<p>build.gradle</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class">repositories </span>&#123;</div><div class="line">    jcenter()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者其他任何一个远程Maven仓库：</p>
<p><strong>使用一个远程Maven仓库</strong></p>
<p>build.gradle</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">repositories</span> &#123;</div><div class="line">    <span class="section">maven</span> &#123;</div><div class="line">        <span class="attribute">url</span> <span class="string">"http://repo.mycompany.com/maven2"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者使用一个lvy仓库：</p>
<p><strong>使用一个远程lvy地址</strong></p>
<p>build.gradle</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">repositories</span> &#123;</div><div class="line">    <span class="section">ivy</span> &#123;</div><div class="line">        <span class="attribute">url</span> <span class="string">"http://repo.mycompany.com/repo"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以通过本地文件系统构建仓库。这对于Maven和lvy都适用。</p>
<p><strong>使用本地lvy地址</strong></p>
<p>build.gradle</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class">repositories </span>&#123;</div><div class="line">    <span class="class">ivy </span>&#123;</div><div class="line">        <span class="comment">// URL can refer to a local directory</span></div><div class="line">        url <span class="string">"../local-repo"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个项目可以有多个仓库。gradle会按照仓库的声明顺序在每一个仓库中去寻找指定的依赖，当第一次找到的时，就停止搜索。</p>
<p>更多关于仓库的声明和使用，见<a href="https://docs.gradle.org/current/userguide/dependency_management.html#sec:repositories" target="_blank" rel="external">Section 23.6, “Repositories”</a>。</p>
<h2 id="6-发布工件">6.发布工件</h2><p>依赖配置同样也可以被用来发布文件。我们称这些文件为<strong>发布工件publication artifacts</strong>，或者仅仅是<strong>工件artifacts</strong>。</p>
<p>插件很好的完成了定义一个项目的工件的工作，因此你不需要做任何特殊的事情来告诉gradle需要发布什么。<br>但是，你需要告诉gradle这些工件要发布到哪里。你需要通过uploadArchives task来将你的项目附加到某个库上。下面是一个发布到远端lvy仓库的例子：</p>
<p><strong>发布到一个远端lvy仓库</strong></p>
<p>build.gradle</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="section">uploadArchives</span> &#123;</div><div class="line">    <span class="section">repositories</span> &#123;</div><div class="line">        <span class="section">ivy</span> &#123;</div><div class="line">            <span class="section">credentials</span> &#123;</div><div class="line">                <span class="attribute">username</span> <span class="string">"username"</span></div><div class="line">                password <span class="string">"pw"</span></div><div class="line">            &#125;</div><div class="line">            url <span class="string">"http://repo.mycompany.com"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，当你运行<code>gradle uploadArchives</code>时，gradle就开始构建并上传jar包了。同时gradle也会生成一个<code>ivy.xml</code>并上传到仓库中。</p>
<p>你也可以上传到Maven仓库中。语法有一些不一样。<strong>注意</strong>你需要使用Maven插件来支持上传到Maven仓库的操作。在这种情况下，gradle会生成一个<code>pom.xml</code>文件，并上传到Maven仓库中。</p>
<p><strong>发布到一个Maven仓库</strong></p>
<p>build.gradle</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">apply plugin: <span class="string">'maven'</span></div><div class="line"></div><div class="line">uploadArchives &#123;</div><div class="line">    repositories &#123;</div><div class="line">        mavenDeployer &#123;</div><div class="line">            repository(url: <span class="string">"file://localhost/tmp/myRepo/"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更多关于发布的信息，请看<a href="https://docs.gradle.org/current/userguide/artifact_management.html" target="_blank" rel="external">Chapter 30, Publishing artifacts</a>。</p>
<h2 id="7-下一步去哪？">7.下一步去哪？</h2><p>关于的依赖解析的全部详情，见<a href="https://docs.gradle.org/current/userguide/dependency_management.html" target="_blank" rel="external">Chapter 23, Dependency Management</a>，关于发布工件的详情见<a href="https://docs.gradle.org/current/userguide/artifact_management.html" target="_blank" rel="external">Chapter 30, Publishing artifacts</a>。</p>
<p>如果你对上述的DSL元素感兴趣，请看<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:configurations(groovy.lang.Closure" target="_blank" rel="external">Project.configurations{}</a>)，<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:repositories(groovy.lang.Closure" target="_blank" rel="external">Project.repositories{}</a>)和<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:dependencies(groovy.lang.Closure" target="_blank" rel="external">Project.dependencies{}</a>)。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/07/10/gradle学习笔记-Gradle 守护进程/" itemprop="url">
                gradle学习笔记-Gradle 守护进程
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-07-10T21:06:55+08:00" content="2016-07-10">
            2016-07-10
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/gradle/" itemprop="url" rel="index">
                  <span itemprop="name">gradle</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/07/10/gradle学习笔记-Gradle 守护进程/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/10/gradle学习笔记-Gradle 守护进程/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>来自维基百科：</p>
<blockquote>
<p>A daemon is a computer program that runs as a background process, rather than being under the direct control of an interactive user.<br>守护进程是一个作为计算机后台进程运行的，而不是直接可以与用户进行交互的程序。</p>
</blockquote>
<p>gradle运行在java虚拟机(JVM)中，并且需要使用几个支持库，这些都会花费不少的初始化时间。因此，有时开启的时候回有一点点慢。解决这个问题的方式就是<strong>gradle守护进程(Daemon)</strong>:一个长时间存活的后台进程，可以使得执行你的构建的速度比其他情况下更为迅速。我们通过避免昂贵的引导进程以及利用缓存，在内存中来保存你的项目数据，来达到提高构建速度的效果。通过使用守护进程执行gradle构建，与不使用守护进程，没有区别的。通过简单的配置，就可以设置是否使用守护进程–gradle中一切操作都是如此的透明。</p>
<h2 id="1-开启守护进程">1.开启守护进程</h2><p>gradle守护进程默认是不可用的，但是我们建议每一个开发者的机器上都将守护进程设置为开启状态（除了持续集成服务器）。以下是几种开启守护进程的方式，但最通用的一种方式是添加这样一行：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">org<span class="selector-class">.gradle</span><span class="selector-class">.daemon</span>=true</div></pre></td></tr></table></figure>
<p>到文件<code>«USER_HOME»/.gradle/gradle.properties</code>，其中<code>«USER_HOME»</code>是你的home目录。以下是几个典型的路径，取决于你的系统平台：</p>
<ul>
<li>C:\Users\<username> (Windows Vista &amp; 7+)</username></li>
<li>/Users/<username> (Mac OS X)</username></li>
<li>/home/<username> (Linux)</username></li>
</ul>
<p>如果那个文件不存在，直接通过文本编辑器创建一个即可。你可以使用另一种方式来开启（或关闭）守护进程，具体步骤可以看下面的FAQ部分。这部分还包含关于守护进程运行的更详细的信息。</p>
<p>一旦你开启了全局守护进程，你所有的构建都会充分利用到这种速度的提升。</p>
<blockquote>
<p><strong><em>关于持续集成</em></strong></p>
<p><em>目前我们建议持续集成不要使用守护进程，取而代之更为可靠方案是为每个构建分配一个新的运行时，原因是运行时是完全与之前的构建隔离的。此外，由于守护进程主要是为了减少构建的启动时间，这一点在CI服务器上并不像是在开发者的机器上那么重要。</em></p>
</blockquote>
<h2 id="2-终止一个正在运行的守护进程">2.终止一个正在运行的守护进程</h2><p>如前所述，守护进程是一个后台进程。你不必担心gradle在你的机器上创建进程，虽然每一个守护进程，在没有任何活动后3小时才会停止。在某些情况下，如果你希望明确的终止一个守护进程，使用<code>gradle --stop</code>即可。</p>
<p>这将终止所有的和当前gradle版本相同的后台进程。如果你安装了JDK，你可以通过<code>jps</code>命令来轻松的核实守护进程是否被停止了。你会看到所有正在运行的名字为“GradleDaemon”的守护进程列表。</p>
<h2 id="3-FAQ">3.FAQ</h2><h3 id="3-1有什么方法能开启守护进程呢？">3.1有什么方法能开启守护进程呢？</h3><p>这里有两种推荐的方式在一个运行环境下开启守护进程:</p>
<ul>
<li>通过环境变量:在GRADLE_OPTS的环境变量下添加标示：<code>Dorg.gradle.daemon=true</code></li>
<li>通过配置文件:添加<code>org.gradle.daemon=true</code>到<code>«GRADLE_USER_HOME»/gradle.properties</code>文件中。</li>
</ul>
<blockquote>
<p><strong>注意：</strong><code>«GRADLE_USER_HOME»</code>默认值为<code>«USER_HOME»/.gradle</code>，<code>«USER_HOME»</code>是当前用户的home目录。这个位置可以通过<code>-g</code>或<code>--gradle-user-home</code>命令来设置。同样也可以通过<code>GRADLE_USER_HOME</code>环境变量和<code>org.gradle.user.home</code>JVM系统属性来设置。</p>
</blockquote>
<p>这两种方法有相同的效果。可根据个人喜好来选择使用。大多数用户使用的是第二种方式。</p>
<p>在Windows下，这个命令会对当前用户开启守护进程：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">if</span> <span class="keyword">not</span> exist <span class="string">"%USERPROFILE%/.gradle"</span> <span class="keyword">mkdir</span> <span class="string">"%USERPROFILE%/.gradle"</span>) &amp;&amp; (echo org.gradle.daemon=true &gt;&gt; <span class="string">"%USERPROFILE%/.gradle/gradle.properties"</span>)</div></pre></td></tr></table></figure>
<p>在UNIX-like的操作系统上，下面的这个bash脚本命令将会对当前用户开启守护进程：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch ~<span class="regexp">/.gradle/gradle</span>.properties &amp;&amp; echo <span class="string">"org.gradle.daemon=true"</span> <span class="meta">&gt;&gt; </span>~<span class="regexp">/.gradle/gradle</span>.properties</div></pre></td></tr></table></figure>
<p>一旦守护进程通过这种方式开启了，所有的构建都将隐式的使用这个守护进程。</p>
<p>可以通过使用<code>--daemon</code>和<code>--no-daemon</code>命令，来针对个别的构建的调用，进行切换开启和关闭使用守护进程。通常情况下，更便捷的方式是对某个环境（例如某个用户账号）开启守护进程，以便于所有的构建使用守护进程，从而不再需要再记得提供<code>--daemon</code>的开关了，</p>
<h3 id="3-2_我该如何关闭守护进程呢？">3.2 我该如何关闭守护进程呢？</h3><p>gradle守护进程默认情况下是不可用的。然而，一旦启用，有时会有需要对某些项目或某些构建调用禁用的场景。</p>
<p><code>--no-daemon</code>命令可以强制指定某个构建不使用守护进程。这个很少用，但在调试某次构建，或者gradle插件时，这个将是一个很有用的方法。当考虑到构建环境时，此命令行开关具有最高的优先级。</p>
<h3 id="3-3_我该如何抑制“please_consider_using_the_Gradle_Daemon”这样的消息呢？">3.3 我该如何抑制“please consider using the Gradle Daemon”这样的消息呢？</h3><p>gradle也许会在构建建议的末尾发出一个“使用守护进程”警告 。为了避开这个警告，你可以通过上面的方式来开启守护进程，或者明确的禁用守护进程。你可以通过<code>--no-daemon</code>命令来明确的关闭守护进程，或者通过上面某种方式开启守护进程，但将<code>org.gradle.daemon</code>属性设置为false。</p>
<p>由于gradle不推荐持续集成构建使用守护进程，所以如果CI环境变量是存在的，那么Gradle不会发出这条消息。</p>
<h3 id="3-4_为什么有超过一个的守护进程在我的机器上？">3.4 为什么有超过一个的守护进程在我的机器上？</h3><p>有几种原因可以解释为什么gradle会创建一个新的守护进程，而不是使用一个已经运行。基本规则是，如果当前没有<strong>闲置</strong>的或<strong>兼容</strong>的守护进程，Gradle将可以启动一个新的守护进程。gradle会自动杀死已经闲置了超过3小时的守护进程，所以你不用担心需要手动的清理它们。</p>
<p><strong>闲置</strong>：一个空闲守护进程是指当前没有执行构建或其他工作的守护进程。</p>
<p><strong>兼容</strong>：一个兼容的守护进程是能够满足构建环境的要求的。java运行时环境是对构建环境兼容性依赖的一个方面的例子，另外一个例子是构建运行环境需要依赖的一套jvm系统参数。</p>
<p>对某些方面的构建环境的请求也许某个守护进程并不满足。如果守护进程在java7的运行环境下，但是被要求的运行环境是java8，然而守护进程并不兼容，那么另一个守护进程一定会被开启。而且，一旦jvm开始运行，java运行时的某些参数是不可以被改变的。对于一个正在运行的JVM，改变内存分配（例如:<code>-Xmx1024m</code>），默认文字的编码，默认位置等，都是不可能的。</p>
<p>“要求构建环境”通常是一些隐式的来自一些client端（例如：gradle命令行，IDE，等）并且明确的通过命令行来开关和设置。见<a href="https://docs.gradle.org/current/userguide/build_environment.html" target="_blank" rel="external">Chapter 11, The Build Environment</a>，详细介绍了如何指定并控制一个构建环境。</p>
<p>下面的JVM系统配置是不可变的。如果被要求的构建环境需要这些配置中的任何一个，并且需要的值和守护进程的JVM的属性是不一样的，那么守护进程就不兼容了。</p>
<ul>
<li>file.encoding</li>
<li>user.language</li>
<li>user.country</li>
<li>user.variant</li>
<li>java.io.tmpdir</li>
<li>javax.net.ssl.keyStore</li>
<li>javax.net.ssl.keyStorePassword</li>
<li>javax.net.ssl.keyStoreType</li>
<li>javax.net.ssl.trustStore</li>
<li>javax.net.ssl.trustStorePassword</li>
<li>javax.net.ssl.trustStoreType</li>
<li>com.sun.management.jmxremote</li>
</ul>
<p>下面的JVM属性，是被启动参数控制的，同样也是不可改变的。守护进程的环境必须完全匹配这些属性，否则就是不兼容的。</p>
<ul>
<li>The maximum heap size (i.e. the -Xmx JVM argument)</li>
<li>The minimum heap size (i.e. the -Xms JVM argument)</li>
<li>The boot classpath (i.e. the -Xbootclasspath argument)</li>
<li>The “assertion” status (i.e. the -ea argument)</li>
</ul>
<p>gradle版本要求是构建环境条件的另一方面。守护进程是被连接到一个具体的gradle运行时的。多个不同版本的gradle项目并行，也是有多个守护进程出现的原因。</p>
<h3 id="3-5_守护进程到底会消耗多少内存？我怎样才能分配更多的内存给它？">3.5 守护进程到底会消耗多少内存？我怎样才能分配更多的内存给它？</h3><p>如果请求的构建环境没有设定最大的内存大小，守护进程将使用最大1GB的内存。它将使用JVM的默认最小内存的大小。1GB对于大多数的构建来说是足够的。较大的有数以百计的子项目的构建，很多的配置，和源代码，也许才能用到1GB或许更多的内存。</p>
<p>为了增加守护进程的内存使用，可以通过设定所请求的构建环境的一些参数来达到目的。详情请见<a href="https://docs.gradle.org/current/userguide/build_environment.html" target="_blank" rel="external"> Chapter 11, The Build Environment</a></p>
<h3 id="3-6_我该如何停止守护进程？">3.6 我该如何停止守护进程？</h3><p>守护进程会在闲置超过3小时之后自动终止。如果你希望提前终止守护进程，你可以通过你的操作系统来杀死这个进程，或者通过输入gradle的<code>--stop</code>命令来终止。<code>--stop</code>命令会终止所有当前版本的gradle的守护进程。</p>
<h3 id="3-7_守护进程什么时候会出错呢？">3.7 守护进程什么时候会出错呢？</h3><p>考虑到工程已经稳定的、透明的并且默默的进入到守护进程中运行。然而守护进程可能偶尔会被损坏或耗尽。一个gradle从多个源代码中任意选取一个执行构建。然而gradle自身的设计，以及大量的通过守护进程进行过的测试，用户构建的脚本，和第三方插件会通过一些缺陷，例如内存泄漏，全局变量泛滥等问题，打破守护进程的平衡。</p>
<p>没有正确的释放资源也有可能导致守护进程（以及正常的构建）异常。当使用Windows进行读写文件后没有正常关闭文件时，对于这种现象尤为敏感。</p>
<p>gradle主动监控堆内存的使用，并且试图检测到内存泄漏的发生点，将可用的内存排出到守护进程中。当gradle查到了一个堆内存空间的问题，gradle守护进程会结束掉当前正在运行的构建，并在下次构建中重启守护进程。这种检测是默认开启的，可用通过系统属性<code>org.gradle.daemon.performance.enable-monitoring</code>设置为false来关闭。</p>
<p>如果怀疑守护进程开始变得不稳定了，那么我们可以轻松的杀死它。再次使用<code>--no-daemon</code>这个开关，可以指定一个构建不使用守护进程。通过这种方式，我们能判断守护进程是否是造成问题的罪魁祸首。</p>
<h2 id="4-什么情况下我不该使用守护进程">4.什么情况下我不该使用守护进程</h2><p>我们推荐所有的开发者的环境中都是用守护进程。但我们<strong>不建议</strong>在持续集成(Continuous Integration)和构建服务器上使用守护进程。</p>
<p>守护进程带来的快速构建，对于坐在机器前的开发人员是格外有意义的。对于持续集成构建服务来说，稳定性和可预见性，是最重要的。对每一个构建使用一个新的完全与上次构建隔离的运行时（比如进程），是一种更可靠的方案。</p>
<h2 id="5-Tools_&amp;_IDEs">5.Tools &amp; IDEs</h2><p>Gradle Tooling API（见<a href="https://docs.gradle.org/current/userguide/embedding.html" target="_blank" rel="external">Chapter 13, Embedding Gradle using the Tooling API</a>），通过其他IDE或者一些gradle整合工具来使用时，<strong>通常</strong>都会用到守护进程来执行构建。如果你通过你的IDE来使用守护进程执行构建，那么你不需要在环境中开启守护进程。</p>
<p>然而除非你已经明确指定了开启守护进程，否则你的命令行执行的构建将不使用守护进程。</p>
<h2 id="6-守护进程是如何提高gradle构建速度的？">6.守护进程是如何提高gradle构建速度的？</h2><p>gradle守护进程是一个<strong>长时间存活</strong>的构建进程。在每次构建之间的间隙，它都会等在那里，直到下次构建。显而易见，多次构建中只加载一次gradle到内存中，与每次构建都加载一次相比，是有很大的好处的。这本身是一个显著的性能优化，但它本身也不会被终止掉。</p>
<p>对于现代的JVM来说，运行时代码优化是意义重大的。例如：热区（是一种作为OpenJDK的基础，由Oracle提供支持的JVM的实现技术）会在运行时对代码进行优化。优化是渐进的，而不是瞬时的。也就是说，代码是在执行过程中逐步优化的，这意味着后面的构建可以执行的更快，这纯粹由于这个优化过程导致的。通过对热区的实验表明，5到10个构建之后，优化的效果将趋于稳定。通过守护进程进行第1次构建，和进行第10次构建，感知层面是有很大的差异的。</p>
<p>守护进程也可以更有效的在内存中缓存的构建。例如：构建所需的类（比如插件，脚本），可以在每次构建之间缓存到内存中。同样，Gradle可将构建数据比如task的输入输出文件的哈希值维持在内存缓存中，用于增量构建。</p>
<h3 id="6-1_未来更强大的功能">6.1 未来更强大的功能</h3><p>目前，守护进程通过内存缓存和JVM的优化使得构建执行的更快。在以后的gradle版本中，守护进程将变得更加智能，以及做到<strong>预先执行</strong>的效果。比如，他可以在构建脚本被编辑之后加入了新的改动或者添加必要的依赖时，假设当前脚本是用来运行的，并立刻开始下载依赖项。</p>
<p>在未来的gradle版本中，将有更多其他的方式来提高构建速度。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/07/10/gradle学习笔记-Gradle Wrapper/" itemprop="url">
                gradle学习笔记-Gradle Wrapper
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-07-10T15:06:55+08:00" content="2016-07-10">
            2016-07-10
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/gradle/" itemprop="url" rel="index">
                  <span itemprop="name">gradle</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/07/10/gradle学习笔记-Gradle Wrapper/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/10/gradle学习笔记-Gradle Wrapper/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>大多数工具都需要在使用之前安装在你的电脑上，虽然简单的安装步骤会让你觉得没什么大碍，但这其实会给用户带来负担。同样重要的是，用户是否会安装正确的版本的工具呢？如果他们正在构建一个版本比较老的项目呢？</p>
</blockquote>
<h2 id="1-通过Wrapper来执行一次构建">1.通过Wrapper来执行一次构建</h2><p>如果一个gradle项目已经设置了wrapper(我们建议所有的项目都这样做)，你可以从项目的根目录执行下列命令之一来进行构建：</p>
<ul>
<li><code>./gradlew &lt;task&gt;</code> (Unix-like系统上使用，如Linux和Mac OS X)</li>
<li><code>gradlew &lt;task&gt;</code> (在Windows上使用gradlew.bat批处理文件)</li>
</ul>
<p>每一个wrapper都绑定在一个指定版本的gradle上，所以当你第一次以一个指定版本的gradle来运行以上的命令，它将会去下载指定的gradle并且去使用它来执行构建。</p>
<p>这不仅意味着你不需要自己手动安装gradle，而且你也能确定当前构建的设计所需要的gradle版本。这使你的历史构建更可靠。只需要在用户指南、在Stack Overflow，在文章的任何地方看到命令行是以<code>gradle ...</code>开头的地方使用适当的语法。（这段没看懂。。）</p>
<p>为了完整起见，并确保您不删除任何重要的文件，这里是一个gradle工程构成包装的文件和目录：</p>
<ul>
<li>gradlew (Unix Shell script)</li>
<li>gradlew.bat (Windows batch file)</li>
<li>gradle/wrapper/gradle-wrapper.jar (Wrapper JAR)</li>
<li>gradle/wrapper/gradle-wrapper.properties (Wrapper properties)</li>
</ul>
<p>如果你想要知道你的gradle分配被存储在哪里，那么你可以在home目录下的<code>$USER_HOME/.gradle/wrapper/dists</code>目录下找到。</p>
<h2 id="2-添加Wrapper到项目中">2.添加Wrapper到项目中</h2><p>wrapper是一种需要检查版本控制的东西。通过分发你的项目wrapper，任何人都可以使用它而无需事先安装gradle。更好的是，它可以保证构建使用正确的gradle版本。当然，由于不需要服务端的任何配置，这也非常有利于<a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="external">持续集成(continuous integration)</a>服务，(服务器定期构建你的项目)。</p>
<p>通过运行wrapper任务，您将wrapper安装到您的项目中。(这个任务总是可用的，即使你不把它添加到你的构建中)。通过命令参数<code>--gradle-version</code>来指定一个gradle版本。你也可以直接通过命令<code>--gradle-distribution-url</code>来设置gradle下载链接。如果没有版本或分配URL指定的wrapper将被配置为使用gradle的版本的wrapper task执行。所以，如果你通过gradle2.4运行wrapper task，然后wrapper的配置将默认配置为版本2.4。</p>
<p>例如：</p>
<p><strong>运行Wrapper task</strong></p>
<p>执行<code>gradle wrapper --gradle-version 2.0</code></p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; gradle wrapper <span class="comment">--gradle-version 2.0</span></div><div class="line">:wrapper</div><div class="line"></div><div class="line">BUILD SUCCESSFUL</div><div class="line"></div><div class="line">Total <span class="built_in">time</span>: <span class="number">1</span> <span class="built_in">secs</span></div></pre></td></tr></table></figure>
<p>wrapper能够通过在构建脚本中配置一些参数来被进一步定制并且执行：</p>
<p>build.gradle</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">task</span> wrapper(<span class="keyword">type</span>: <span class="type">Wrapper</span>) &#123;</div><div class="line">    gradleVersion = '2.0'</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这样的一个执行之后，你会发现在你的项目目录中的新的或更新的文件（一旦在wrapper task的默认配置被用到）。</p>
<p><strong>Wrapper 生成的文件</strong></p>
<p>Build layout</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">simple/</div><div class="line">  gradlew</div><div class="line">  gradlew<span class="selector-class">.bat</span></div><div class="line">  gradle/wrapper/</div><div class="line">    gradle-wrapper<span class="selector-class">.jar</span></div><div class="line">    gradle-wrapper.properties</div></pre></td></tr></table></figure>
<p>所有这些文件都应该提交给您的版本控制系统。这只需要做一次。在这些文件已经添加到项目中之后，项目构建时就应该加<code>gradlew</code>命令了。<code>gradlew</code>命令可以按照和<code>gradle</code>完全一样的方式来使用。</p>
<p>如果你想切换到一个新的gradle，你不需要重新运行wrapper task。在<code>gradle-wrapper</code>中更改相应的入口就足够了。属性文件，但如果你想要体验新的版本的gradle wrapper，那么你就需要重新生成wrapper文件。</p>
<h2 id="3-配置">3.配置</h2><p>如果你通过<code>gradlew</code>来运行gradle，wrapper会去检查是否有一个可用版本的gradle。如果这样的话它代表将<code>gradlew</code>命令带上所有的参数传递到当前版本的gradle命令上来。如果没有发现一个一个可用的gradle，它就会去自动下载。</p>
<p>当你配置wrapper task，你可以指定一个你想要使用的gradle版本。的gradlew命令将从gradle库下载合适的版本。或者，你也可以指定一个gradle的下载链接。的gradlew命令将使用这个URL下载gradle。如果你既没有指定版本，也没有指定下载链接，那么<code>gradlew</code>命令将下载任意一个版本的gralde来生成wrapper文件。</p>
<p>有关如何配置包装的详细信息，参见<a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.wrapper.Wrapper.html" target="_blank" rel="external">Wrapper</a>类API文档。</p>
<p>如果你在使用<code>gradlew</code>进行构建的过程中，不希望有任何下载产生，只需将gradle的zip包放在你的wrapper配置指定的位置并添加到您的版本控制工具即可。相对路径的支持-您可以指定gradle的文件到一个相对于gradle-wrapper.properties文件的位置。</p>
<p>如果你通过wrapper来构建，机器上安装的任何版本的gradle都会被忽略。</p>
<h2 id="4-验证下载的gradle">4.验证下载的gradle</h2><p>gradle wrapper通过SHA-256哈希比较来校验下载的gradle。这种方式通过阻止中间人篡改下载的gradle来进行攻击，从而提高了安全性。</p>
<p>要启用这个功能，你要先计算一个已知的gradle版本的SHA-256哈希码。你可以通过<code>shasum</code>命令在Linux、OSX或者Windows(通过 Cygwin)上来生成SHA-256哈希码。</p>
<p><strong>生成一个SHA-256 hash</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="selector-tag">shasum</span> <span class="selector-tag">-a</span> 256 <span class="selector-tag">gradle-2</span><span class="selector-class">.4-all</span><span class="selector-class">.zip</span></div><div class="line">371<span class="selector-tag">cb9fbebbe9880d147f59bab36d61eee122854ef8c9ee1ecf12b82368bcf10</span>  <span class="selector-tag">gradle-2</span><span class="selector-class">.4-all</span><span class="selector-class">.zip</span></div></pre></td></tr></table></figure>
<p>通过将<code>distributionSha256Sum</code>属性配置添加到<code>gradle-wrapper.properties</code>来返回校验的哈希码。</p>
<p><strong>配置SHA-256校验</strong></p>
<p>gradle-wrapper.properties</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">distributionSha256Sum</span>=<span class="number">371</span>cb9fbebbe9880d147f59bab36d61eee122854ef8c9ee1ecf12b82368bcf10</div></pre></td></tr></table></figure>
<h2 id="5-UNIX文件的权限">5.UNIX文件的权限</h2><p>对wrapper task添加适当的文件权限来允许*NIX上的命令行上可以执行<code>gradlew</code>命令。我们不确定其他版本控制系统如何处理这个。但<code>sh gradlew</code>这个命令总是很有效的。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/8/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://dannylee1991.github.io/images/avatar.jpg" alt="DannyLee佳楠" itemprop="image"/>
          <p class="site-author-name" itemprop="name">DannyLee佳楠</p>
        </div>
        <p class="site-description motion-element" itemprop="description">一只在迈向机器学习道路上狂奔的程序猿.</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">107</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/DannyLee1991" target="_blank">GitHub</a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DannyLee佳楠</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"dannylee1991"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     
  	<script src="/js/ua-parser.min.js"></script>
  	<script src="/js/hook-duoshuo.js"></script>
  

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
